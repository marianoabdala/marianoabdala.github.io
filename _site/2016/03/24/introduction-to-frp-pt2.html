<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Introduction to FRP (part 2)</title>
  <meta name="description" content="This is the second part of the Introduction to FRP series. Here’s the first part.">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://zerously.com/2016/03/24/introduction-to-frp-pt2.html">
  <link rel="alternate" type="application/rss+xml" title="Mariano Abdala" href="http://zerously.com/feed.xml">

  <link rel="icon" type="image/png" href="/images/favicon_32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/images/favicon_16.png" sizes="16x16" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Mariano Abdala</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Introduction to FRP (part 2)</h1>
    <p class="post-meta"><time datetime="2016-03-24T21:26:45-03:00" itemprop="datePublished">Mar 24, 2016</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>This is the second part of the Introduction to FRP series. Here’s the <a href="/2016/03/20/introduction-to-frp-pt1.html">first</a> part.</p>

<p>As mentioned on the first part of this series, we are going to focus on ReactiveCocoa 4 for showing examples on how to implement FRP concepts. I’ll assume you already installed it on your project. If you haven’t you may want to read <a href="https://github.com/ReactiveCocoa/ReactiveCocoa#getting-started">this</a>.</p>

<p>Let’s use the example of the register button that will be enabled when both the username and the password are valid, as long as the register button hasn’t been pressed already and we are registering the user via API.</p>

<p>If you recall, this is what we’ve said:</p>

<blockquote>
  <p>Now, this is what FRP programming will normally do:<br />
1. <strong>Bind</strong> the register button’s enabled property to when both the username and the password are valid, as long as the register button hasn’t been pressed already and we aren’t registering the user via API.</p>
</blockquote>

<p>So let start with the bind.</p>

<h1 id="bindings">Bindings</h1>

<p>ReactiveCocoa has a really cool, smart and practical way of binding things via the use of the <code class="highlighter-rouge">&lt;~</code> operator. Let’s see an example.</p>

<p>Let’s assume we have a <code class="highlighter-rouge">UserViewModel</code> that looks more less like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class UserViewModel {

	var name = MutableProperty&lt;String?&gt;(nil)
}
</code></pre>
</div>

<p>Then, this test would pass without issues:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class ReactiveTests: XCTestCase {
    
    func testSimpleBind() {
        
        let newName = "Mariano Abdala"
        let userViewModel = UserViewModel()
        let nameBindedProperty = MutableProperty&lt;String?&gt;(nil)
        
        nameBindedProperty &lt;~ userViewModel.name

        userViewModel.name.value = newName

        XCTAssertEqual(userViewModel.name.value, newName)
        XCTAssertEqual(nameBindedProperty.value, newName)
    }
}
</code></pre>
</div>

<p>We will, of course, want to bind a <code class="highlighter-rouge">ViewModel</code> to a <code class="highlighter-rouge">UIView</code>’s property. In this case, the user’s name would probably end up being bounded to a <code class="highlighter-rouge">userNameLabel</code>’s <code class="highlighter-rouge">text</code>.</p>

<p>In the past you’d do something like<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>RAC(self.userNameLabel, text) = userViewModel.name;
</code></pre>
</div>

<p>But that won’t work in RAC 4. In RAC 4 you can only bind, using the <code class="highlighter-rouge">&lt;~</code> operator, to a <code class="highlighter-rouge">MutableProperty&lt;T&gt;</code>. But worry not, because <a href="http://blog.scottlogic.com/ceberhardt/">Colin Eberhardt</a> came up with an <a href="https://github.com/ColinEberhardt/ReactiveTwitterSearch/blob/master/ReactiveTwitterSearch/Util/UIKitExtensions.swift">easy way</a> to turn almost any property (including <code class="highlighter-rouge">UIKit</code>’s) into a RAC 4 <code class="highlighter-rouge">MutableProperty&lt;T&gt;</code>. You’ll most likely want to add that file<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup> to any project that uses RAC 4.</p>

<p>Let’s see how this looks like with a <code class="highlighter-rouge">UILabel</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class ReactiveTests: XCTestCase {
    
    func testLabelBind() {
        
        let newName = "Mariano Abdala"
        let userViewModel = UserViewModel()
        let userNameLabel = UILabel()
        
        userNameLabel.rac_text &lt;~ userViewModel.name

        userViewModel.name.value = newName

        XCTAssertEqual(userViewModel.name.value, newName)
        XCTAssertEqual(userNameLabel.text, newName)
    }
}
</code></pre>
</div>

<p>This may not look like much, but once your View Controllers start looking like just a bunch of simple bindings to your models, that’s when this starts to pay out. And isn’t that what one of the View Controller’s main responsibility is, to bind the View to the Model’s data?</p>

<p>Let’s then…</p>

<blockquote>
  <ol>
    <li><strong>Bind the register button’s enabled property to when both the username and the password are valid</strong>, as long as the register button hasn’t been pressed already and we aren’t registering the user via API.</li>
  </ol>
</blockquote>

<p>This is going to take a few steps, we’ll need to cover hot and cold signals, signal aggregation, transformations and chaining (!), so hang tight.</p>

<h1 id="signal-transformations">Signal transformations</h1>
<p>The easiest way to validate that the username, or the password or any other text, are valid is via a transformation. We will transform the user name text into a <code class="highlighter-rouge">Bool</code> that will indicate whether the username is valid or not.</p>

<p>To do that we need a signal. Luckily, all <code class="highlighter-rouge">MutableProperty&lt;T&gt;</code> have one. The prefered method to transform one thing into another is <code class="highlighter-rouge">map</code>.</p>

<p>We won’t be covering all other transformations, but what’s important is that RAC 4 <code class="highlighter-rouge">Signal</code>’s <code class="highlighter-rouge">map</code> doesn’t return a new value, but a new <code class="highlighter-rouge">Signal</code>. Which allows us to do both, biding <em>and</em> chaining.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class ReactiveTests: XCTestCase {
    
    func testCompoundBind() {
        
        let registerButton = UIButton()
        let usernameTextField = UITextField()
        
        registerButton.rac_enabled &lt;~ usernameTextField.rac_text.signal.map { (text) -&gt; Bool in
            
            return text.characters.count &gt;= 8
        }

        XCTAssertFalse(registerButton.enabled)

        usernameTextField.text = "mariano@zerously.com"
        usernameTextField.sendActionsForControlEvents(.EditingChanged)
        
        XCTAssertTrue(registerButton.enabled)
    }
}
</code></pre>
</div>

<p>As you can see here, what we are doing is mapping the text of the username to whether it’s valid or not. This is what we meant by a stream being <em>a river with all it’s water</em>: we can fully define whether the register button is enabled or not, across time and across values.</p>

<p>There’s a couple new concepts in this test though.</p>

<p><code class="highlighter-rouge">usernameTextField.sendActionsForControlEvents(.EditingChanged)</code> is there so that the proper event’s will be triggered when setting the text by hand. You won’t have to worry about this with a live <code class="highlighter-rouge">UITextField</code> on a <code class="highlighter-rouge">UIViewController</code>.</p>

<p>For the sake of clariry, let’s wrap that into an <code class="highlighter-rouge">extension</code> and assume it’s present in future code.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>extension UITextField {
    
    func inputText(text: String) {
        
        self.text = text
        self.sendActionsForControlEvents(.EditingChanged)
    }
}
</code></pre>
</div>

<p>And then there’s the <code class="highlighter-rouge">rac_enabled</code> property that isn’t present on the <code class="highlighter-rouge">Util.swift</code> file we mentioned before.</p>

<p>To add new <code class="highlighter-rouge">UIKit</code> properties simply add to that file something like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>extension UIControl {
    public var rac_enabled: MutableProperty&lt;Bool&gt; {
        return lazyMutableProperty(self, key: &amp;AssociationKey.enabled, setter: { self.enabled = $0 }, getter: { self.enabled })
    }
}
</code></pre>
</div>

<p>But there’s one last a catch here. This test will fail on the first assert. Which brings us to hot and cold signals.</p>

<h1 id="hot-and-cold-signals">Hot and cold signals</h1>
<p>So, why did that test fail on the first assert?</p>

<p>Since we were using a hot signal, the binding will only be set once the value of the textfield changes for the first time. Remember that:</p>

<blockquote>
  <p>If you get the current value (which was set in the past) alongside with whichever new values are set in the future binded into your property then you are using a <strong>cold signal</strong>.<br />
If you only start getting the new values (whichever are set in the future) binded into your property then you are using a <strong>hot signal</strong>.</p>
</blockquote>

<p>In this particular case, if we want the enabled to be “computed” false, we need to consider the preexisting username text value, which is <code class="highlighter-rouge">nil</code>.</p>

<p>How do we get a cold signal? Using the property’s <code class="highlighter-rouge">SignalProducer</code> instead of the <code class="highlighter-rouge">Signal</code>. It’s that easy.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class ReactiveTests: XCTestCase {

    func testCompoundBind() {
        
        let registerButton = UIButton()
        let userNameTextField = UITextField()
        
        registerButton.rac_enabled &lt;~ userNameTextField.rac_text.producer.map { (text) -&gt; Bool in
            
            return text.characters.count &gt;= 8
        }

        XCTAssertFalse(registerButton.enabled)
        userNameTextField.inputText("mariano@zerously.com")
        XCTAssertTrue(registerButton.enabled)
    }
}
</code></pre>
</div>

<p>All tests passing, now we need to validate the password as well, how do we do that?</p>

<h1 id="signal-aggregation">Signal Aggregation</h1>

<p>Have you noticed the name of the test? Exactly, “compound”, what we need to do is combine both signals, the username’s and the password’s.</p>

<p>And here we go, we have the first part of the goal resolved.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class ReactiveTests: XCTestCase {

    func testCompoundBind() {
        
        let registerButton = UIButton()
        let usernameTextField = UITextField()
        let passwordTextField = UITextField()
        
        registerButton.rac_enabled &lt;~
            combineLatest(usernameTextField.rac_text.producer, passwordTextField.rac_text.producer)
            .map { (username, password) -&gt; Bool in
            
	            return username.characters.count &gt;= 8 &amp;&amp;
	                    password.characters.count &gt;= 8
            }

        XCTAssertFalse(registerButton.enabled)
        usernameTextField.inputText("mariano@zerously.com")
        XCTAssertFalse(registerButton.enabled)
        passwordTextField.inputText("pa55worD")
        XCTAssertTrue(registerButton.enabled)
    }
}
</code></pre>
</div>

<p>I’m sure you used apps with <a href="https://www.reddit.com/r/Jokes/comments/1v4bpa/passwords/">way more creative algorithms</a>. ;-)</p>

<p>There are other kinds of signal aggregation and operations, but we aren’t going to cover that here.</p>

<h1 id="chaining">Chaining</h1>
<p>While we were dealing with our goal of enabling the register button when both the username and the password are valid, we were unadvertedly using chaining already. <code class="highlighter-rouge">combineLatest</code> returns a <code class="highlighter-rouge">Signal</code> (or <code class="highlighter-rouge">SignalProducer</code>) to which we can perform other transformations (like mapping) and that’s exactly what chaining is all about.</p>

<p>But, this is awful, shall we move this into a View Model?</p>

<div class="highlighter-rouge"><pre class="highlight"><code>struct RegisterViewModel {
    
    let username = MutableProperty&lt;String?&gt;(nil)
    let password = MutableProperty&lt;String?&gt;(nil)
    let registerEnabledSignalProducer: SignalProducer&lt;Bool, NoError&gt;
    
    init() {

        self.registerEnabledSignalProducer = combineLatest(self.username.producer, self.password.producer)
            .map { (username, password) -&gt; Bool in

                return username?.characters.count &gt;= 8 &amp;&amp;
                        password?.characters.count &gt;= 8
            }
    }
}

class ReactiveTests: XCTestCase {
    
    func testModelBind() {
        
        let registerViewModel = RegisterViewModel()
        let registerButton = UIButton()
        let usernameTextField = UITextField()
        let passwordTextField = UITextField()
        
        registerViewModel.username &lt;~ usernameTextField.rac_text
        registerViewModel.password &lt;~ passwordTextField.rac_text
        registerButton.rac_enabled &lt;~ registerViewModel.registerEnabledSignalProducer

        XCTAssertFalse(registerButton.enabled)
        usernameTextField.inputText("mariano@zerously.com")
        XCTAssertFalse(registerButton.enabled)
        passwordTextField.inputText("pa55worD")
        XCTAssertTrue(registerButton.enabled)
    }
}
</code></pre>
</div>

<p><strong>That’s better!</strong> See how all our code starts looking like simple bindings?</p>

<h1 id="next">Next</h1>
<p><a href="/2016/04/03/introduction-to-frp-pt3.html">Part 3</a>: Applied networking with ReactiveCocoa 4.<br />
<a href="/2016/04/03/introduction-to-frp-pt4.html">Part 4</a>: Using ReactiveCocoa 4 on an app.</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>Notice that this is Objc. RAC 4 is mostly built around Swift. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>If you do that, I’d suggest that you change the <code class="highlighter-rouge">rac_text</code> type to <code class="highlighter-rouge">MutableProperty&lt;String?&gt;</code>. Since that’s the type of <code class="highlighter-rouge">UILabel</code>’s text property, so should be the type of the <code class="highlighter-rouge">rac_text</code> <code class="highlighter-rouge">MutableProperty</code>. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Mariano Abdala</li>
          <li><a href="mailto:mariano@zerously.com">mariano@zerously.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/marianoabdala"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">marianoabdala</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/marianoabdala"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">marianoabdala</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writings of Mariano Abdala. iOS Developer, host at <a href="https://twitter.com/nscoderba">@NSCoderBA</a> and organizer at <a href="https://twitter.com/nsconfarg">@NSConfArg</a>.</p>
      </div>
    </div>

  </div>

</footer>


    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-17657932-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>

</html>
