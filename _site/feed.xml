<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mariano Abdala</title>
    <description>Writings of Mariano Abdala. iOS Developer, host at @NSCoderBA and organizer at @NSConfArg.
</description>
    <link>http://zerously.com/</link>
    <atom:link href="http://zerously.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 09 Jun 2016 18:12:44 -0300</pubDate>
    <lastBuildDate>Thu, 09 Jun 2016 18:12:44 -0300</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Nested Functions</title>
        <description>&lt;p&gt;I came across a neat Swift feature today that I wasn’t aware of: you can nest functions.&lt;/p&gt;

&lt;p&gt;Nesting functions work great for typically large functions that you want to split into smaller chunks but that make no sense if called from anywhere else, not even from &lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A good example of this kind of functions would be one that serves to configure some views in a view controller. In a very common scenario, each of said views would required some 4 or 5 lines of code.&lt;/p&gt;

&lt;h4 id=&quot;the-comment-approach&quot;&gt;The comment approach&lt;/h4&gt;
&lt;p&gt;One aproach is to have comments signaling the beginning of each section, like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Username label
self.usernameLabel.accessibilityHint = &quot;User name&quot;
self.usernameLabel.shadowColor = UIColor.cyanColor()
self.usernameLabel.textAlignment = .Justified

// Next button
self.nextButton.layer.cornerRadius = 4
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But you may end up with a hundred lines long method. &lt;strong&gt;Nobody wants that.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;the-private-function-approach&quot;&gt;The private function approach&lt;/h4&gt;
&lt;p&gt;A different approach (the one I used up until now) was to wrap those little sections into functions and call them one at a time, so that my function would like somewhat like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private func configureViews() {
    
  self.configureAvatarImageView()
  self.configureUsernameLabel()
  self.configureNextButton()
}

private func configureAvatarImageView() {

  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The downside with this approach is that we could call &lt;code class=&quot;highlighter-rouge&quot;&gt;configureAvatarImageView&lt;/code&gt; from any other part of our view controller, when, in most cases, it doesn’t make any sense. Given that having it accessible means polluting our auto-completion and allowing us to mistakingly call it from somewhere we aren’t supposed to… &lt;strong&gt;Nobody wants that.&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&quot;the-nested-function-approach&quot;&gt;The nested function approach&lt;/h4&gt;

&lt;p&gt;Nested functions allows us to define functions inside other functions. Those inner functions are only accessible from whithin the outer function. Making our code much more organised and tidy. Inner functions also have access to variables defined in the outer function.&lt;/p&gt;

&lt;p&gt;Let’s see how our &lt;code class=&quot;highlighter-rouge&quot;&gt;configureViews&lt;/code&gt; would look like using nested functions:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private func configureViews() {
	
  func configureAvatarImageView() {

    ...
  }

  func configureUsernameLabel() {

    ...
  }

  configureNextButton() {
  
    ...
  }

  configureAvatarImageView()
  configureUsernameLabel()
  configureNextButton()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is how you’d probably want to do it. Simple, tidy and thanks to nested functions &lt;strong&gt;contained&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Note: Ideally, you’d be able to call the inner functions on top of the function, to serve as a sort of summary, but today that’s not available. For that matter, I created a &lt;a href=&quot;https://bugs.swift.org/browse/SR-1721&quot;&gt;bug report&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jun 2016 16:18:06 -0300</pubDate>
        <link>http://zerously.com/2016/06/09/nested-functions.html</link>
        <guid isPermaLink="true">http://zerously.com/2016/06/09/nested-functions.html</guid>
        
        
      </item>
    
      <item>
        <title>Introduction to FRP (part 4)</title>
        <description>&lt;p&gt;This is the fourth part of the Introduction to FRP series. Here’s the &lt;a href=&quot;/2016/03/20/introduction-to-frp-pt1.html&quot;&gt;first&lt;/a&gt;, &lt;a href=&quot;/2016/03/24/introduction-to-frp-pt2.html&quot;&gt;second&lt;/a&gt; and &lt;a href=&quot;/2016/04/03/introduction-to-frp-pt3.html&quot;&gt;third&lt;/a&gt; parts.&lt;/p&gt;

&lt;p&gt;Believe it or not, this is the easy part, implementing this on a ViewController to use it on an app.&lt;/p&gt;

&lt;p&gt;Let’s do just that, let’s create a ViewController on a Storyboard with the same UI elements as the tests and simply copy the bindings into the new ViewController.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ViewController: UIViewController {

    @IBOutlet private weak var errorLabel: UILabel!
    @IBOutlet private weak var usernameTextField: UITextField!
    @IBOutlet private weak var passwordTextField: UITextField!
    @IBOutlet private weak var activityIndicatorView: UIActivityIndicatorView!
    @IBOutlet private weak var registerButton: UIButton!
    
    private let registerService: RegisterServiceProtocol
    private let registerViewModel: RegisterViewModel

    required init?(coder aDecoder: NSCoder) {

        self.registerService = RegisterService(urlSession: NSURLSession.sharedSession())
        self.registerViewModel = RegisterViewModel(registerService: self.registerService)

        super.init(coder: aDecoder)
    }
    
    override func viewDidLoad() {
        
        super.viewDidLoad()
        self.setupBindings()
    }
    
    private func setupBindings() {
        
        self.errorLabel.rac_text &amp;lt;~ registerViewModel.registryError
        self.registerViewModel.username &amp;lt;~ self.usernameTextField.rac_text
        self.registerViewModel.password &amp;lt;~ self.passwordTextField.rac_text
        self.activityIndicatorView.rac_animating &amp;lt;~ registerViewModel.isRegistering
        self.registerButton.rac_enabled &amp;lt;~ self.registerViewModel.registerEnabledSignalProducer
    }
    
    @IBAction private func registerButtonTapped(sender: AnyObject) {
        
        self.registerViewModel.register().observeCompleted { [weak self] in
            
            guard let strongSelf = self else {
                
                return
            }
            
            strongSelf.performSegueWithIdentifier(&quot;registerIdentifier&quot;, sender: strongSelf)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is not a excerp. This is &lt;strong&gt;the whole thing&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This code covers all of this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Hook into the textfields’ &lt;code class=&quot;highlighter-rouge&quot;&gt;shouldChangeCharactersInRange:replacementString:&lt;/code&gt; delegate method.&lt;/li&gt;
    &lt;li&gt;Every time the text changes, check whether it’s valid or not.&lt;/li&gt;
    &lt;li&gt;Check if the counterpart textfield’s text is valid.&lt;/li&gt;
    &lt;li&gt;Check the &lt;code class=&quot;highlighter-rouge&quot;&gt;isRegistering&lt;/code&gt; property is &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.&lt;/li&gt;
    &lt;li&gt;Enable the register button.&lt;/li&gt;
    &lt;li&gt;Hook into the register button &lt;code class=&quot;highlighter-rouge&quot;&gt;UIControlEventTouchUpInside&lt;/code&gt; event.&lt;/li&gt;
    &lt;li&gt;When the register button is tapped collect the username and password values, call the register API and set the &lt;code class=&quot;highlighter-rouge&quot;&gt;isRegistering&lt;/code&gt; property to &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;And more! It also makes the actual API call, handles errors and pushes a new ViewController when succeded.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;FRP leads us to structure our code in such a way that the effort required to implement dependency injection, separation of concerns, testing and other good practices is marginal.&lt;/p&gt;

&lt;p&gt;The amount of code that’s not testable is minimal and will rarely fail.&lt;/p&gt;

&lt;p&gt;FRP is &lt;em&gt;intrusive&lt;/em&gt;, meaning that it influences the domain design as well as its implementation and that removing it would require a great amount of time and effort, but there’s a big enough community to support and prevent scenarios where you’d have to do so.&lt;/p&gt;

&lt;h1 id=&quot;more&quot;&gt;More&lt;/h1&gt;
&lt;p&gt;A sample project with all the code and working app can be found in &lt;a href=&quot;https://github.com/marianoabdala/Introduction-to-FRP&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Apr 2016 19:55:06 -0300</pubDate>
        <link>http://zerously.com/2016/04/03/introduction-to-frp-pt4.html</link>
        <guid isPermaLink="true">http://zerously.com/2016/04/03/introduction-to-frp-pt4.html</guid>
        
        
      </item>
    
      <item>
        <title>Introduction to FRP (part 3)</title>
        <description>&lt;p&gt;This is the third part of the Introduction to FRP series. Here’s the &lt;a href=&quot;/2016/03/20/introduction-to-frp-pt1.html&quot;&gt;first&lt;/a&gt; and &lt;a href=&quot;/2016/03/24/introduction-to-frp-pt2.html&quot;&gt;second&lt;/a&gt; parts.&lt;/p&gt;

&lt;p&gt;Here, we’ll be covering networking. In itself, networking with FRP isn’t a long subject, but it provides us with an excuse to cover many generic FRP concepts that normally happen (and are easier to explain and grasp) when you use it to manage networking.&lt;/p&gt;

&lt;p&gt;Let’s pick it up where we left it and focus on the second part of the statement:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Bind the register button’s enabled property to when both the username and the password are valid, &lt;strong&gt;as long as the register button hasn’t been pressed already and we aren’t registering the user via API&lt;/strong&gt;.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;To achieve this we’ll add a &lt;code class=&quot;highlighter-rouge&quot;&gt;isRegistering&lt;/code&gt; property on the &lt;code class=&quot;highlighter-rouge&quot;&gt;RegisterViewModel&lt;/code&gt; and update the &lt;code class=&quot;highlighter-rouge&quot;&gt;registerEnabledSignalProducer&lt;/code&gt; that drives whether the register button is enabled:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct RegisterViewModel {

    let username = MutableProperty&amp;lt;String?&amp;gt;(nil)
    let password = MutableProperty&amp;lt;String?&amp;gt;(nil)
    let registerEnabledSignalProducer: SignalProducer&amp;lt;Bool, NoError&amp;gt;
    let isRegistering = MutableProperty(false)

    init() {

        self.registerEnabledSignalProducer = combineLatest(self.username.producer, self.password.producer, self.isRegistering.producer)
            .map { (username, password, isRegistering) -&amp;gt; Bool in

              return username?.characters.count &amp;gt;= 8 &amp;amp;&amp;amp;
                      password?.characters.count &amp;gt;= 8 &amp;amp;&amp;amp;
                      isRegistering == false
            }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now all we need to do is set the value of the &lt;code class=&quot;highlighter-rouge&quot;&gt;isRegistering&lt;/code&gt; property when we call the API and when the API responds. Notice Also that we combined username, password and isRegistering using &lt;code class=&quot;highlighter-rouge&quot;&gt;combineLatest&lt;/code&gt;, which allows us to combine up to 10 &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt;s/&lt;code class=&quot;highlighter-rouge&quot;&gt;SignalProducer&lt;/code&gt;s!!&lt;/p&gt;

&lt;p&gt;So, let’s get our hands dirty, shall we? Let’s make and actual API call and handle it, even though &lt;strong&gt;we already covered the original requirements&lt;/strong&gt;.&lt;/p&gt;

&lt;h1 id=&quot;simple-service&quot;&gt;Simple Service&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct RegisterService {
    
    private let urlSession: NSURLSession
    
    init(urlSession: NSURLSession) {
        
        self.urlSession = urlSession
    }
    
    func register(username username: String, password: String) -&amp;gt; SignalProducer&amp;lt;(NSData, NSURLResponse), NSError&amp;gt; {

        // Let&#39;s assume we are inserting username and password to the request.
        guard let url = NSURL(string: &quot;http://zerously.com/misc/register.json&quot;) else {
            
            return SignalProducer&amp;lt;(NSData, NSURLResponse), NSError&amp;gt;(error: NSError(domain: &quot;RegisterService&quot;, code: -1, userInfo: [&quot;Reason&quot;: &quot;Invalid URL.&quot;]))
        }
        
        let request = NSURLRequest(URL: url)
        return self.urlSession.rac_dataWithRequest(request)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The key to this service is that we aren’t returning a value or a model, we are returning a SignalProducer, for the consumer to transform, manage and handle; and ReactiveCocoa has a very handy method to achieve that right of from a &lt;code class=&quot;highlighter-rouge&quot;&gt;NSURLSession&lt;/code&gt;, the &lt;code class=&quot;highlighter-rouge&quot;&gt;rac_dataWithRequest(_:)&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;For simplicity sake we aren’t adding username and password to the request, but we could verify if they are valid and return a &lt;code class=&quot;highlighter-rouge&quot;&gt;SignalProducer&lt;/code&gt; that will produce an error immediately in a similary way as the one shown in the code, for verifying the URL is valid.&lt;/p&gt;

&lt;h1 id=&quot;usage-from-the-view-model&quot;&gt;Usage from the View Model&lt;/h1&gt;

&lt;p&gt;Here’s how a rough call to this would look like from the ViewModel:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct RegisterViewModel {

    let registerService: RegisterService

    init(registerService: RegisterService) {

        self.registerService = registerService
        ...
    }

    func register() {

        guard let username = self.username.value,
                    password = self.password.value else {

                return
        }

        self.isRegistering.value = true

        self.registerService.register(username: username, password: password)
            .observeOn(UIScheduler())
            .startWithNext {

                self.isRegistering.value = false
            }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;A few things to note here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We are injecting the &lt;code class=&quot;highlighter-rouge&quot;&gt;RegisterService&lt;/code&gt; into the ViewModel, we’ll see how that’s useful later.&lt;/li&gt;
  &lt;li&gt;We are handling the happy path for the &lt;code class=&quot;highlighter-rouge&quot;&gt;isRegistering&lt;/code&gt; property we created previously.&lt;/li&gt;
  &lt;li&gt;We are calling &lt;code class=&quot;highlighter-rouge&quot;&gt;.observeOn(UIScheduler())&lt;/code&gt; to make sure we are working on the main thread from here on since the changes in &lt;code class=&quot;highlighter-rouge&quot;&gt;isRegistering&lt;/code&gt; will affect UI.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Seems like we are forgetting something? We aren’t doing anything with the result of the API call! We need to inform the ViewController that we finished registering the user successfully, so…&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func register() -&amp;gt; Bool {

	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;What? &lt;strong&gt;No!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;By now, we know much more expresive and rective ways of doing this… It’ll require us not to consume, but to create a &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func register() -&amp;gt; Signal&amp;lt;Void, NoError&amp;gt; {

    var didRegisterSink: Observer&amp;lt;Void, NoError&amp;gt;?
    let didRegisterSignal = Signal&amp;lt;Void, NoError&amp;gt; { (sink) -&amp;gt; Disposable? in
        
        didRegisterSink = sink
        return nil
    }
    
    self.isRegistering.value = true

    self.registerService.register(username: username, password: password)
        .observeOn(UIScheduler())
        .startWithNext {

            self.isRegistering.value = false
            didRegisterSink?.sendCompleted()
    	}
    
    return didRegisterSignal
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So, how does this work?&lt;/p&gt;

&lt;p&gt;Every time you create a &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt; or a &lt;code class=&quot;highlighter-rouge&quot;&gt;SignalProducer&lt;/code&gt; you’ll get a &lt;code class=&quot;highlighter-rouge&quot;&gt;sink&lt;/code&gt; that’s going to be the reciever of the events. Just like to &lt;code class=&quot;highlighter-rouge&quot;&gt;observeNext&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;observeCompleted&lt;/code&gt; you can &lt;code class=&quot;highlighter-rouge&quot;&gt;sendNext&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;sendCompleted&lt;/code&gt; on the other side, on the sink.&lt;/p&gt;

&lt;p&gt;We can now bind this to our test.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func testAPICall() {
    
    let registerService = RegisterService(urlSession: NSURLSession.sharedSession())
    let registerViewModel = RegisterViewModel(registerService: registerService)
    let registerButton = UIButton()
    let usernameTextField = UITextField()
    let passwordTextField = UITextField()
    
    registerViewModel.username &amp;lt;~ usernameTextField.rac_text
    registerViewModel.password &amp;lt;~ passwordTextField.rac_text
    registerButton.rac_enabled &amp;lt;~ registerViewModel.registerEnabledSignalProducer

    XCTAssertFalse(registerButton.enabled)
    
    usernameTextField.inputText(&quot;mariano@zerously.com&quot;)
    
    XCTAssertFalse(registerButton.enabled)
    
    passwordTextField.inputText(&quot;pa55worD&quot;)
    
    XCTAssertTrue(registerButton.enabled)
    
    let expectation = expectationWithDescription(&quot;Wait for register to return&quot;)

    registerViewModel.register().observeCompleted {

        XCTAssertTrue(registerButton.enabled)

        // On a View Controller, we&#39;d probably move to the onboarding screen.
        // Since this is a test, we&#39;ll simply mark the expectation as fulfilled.
        expectation.fulfill()
    }
    
    XCTAssertFalse(registerButton.enabled)
    
    waitForExpectationsWithTimeout(10) { (error) in
        
        if error != nil {

            XCTFail()
        }
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;non-trivial-behaviour&quot;&gt;Non-trivial behaviour&lt;/h1&gt;

&lt;p&gt;As we add non-trivial behaviour to this example, we have to make sure we have errors handled too, so let’s add a &lt;code class=&quot;highlighter-rouge&quot;&gt;registryError&lt;/code&gt; property and bind it in our tests to a &lt;code class=&quot;highlighter-rouge&quot;&gt;errorLabel&lt;/code&gt;. While we are here, let’s add an &lt;code class=&quot;highlighter-rouge&quot;&gt;activityIndicatorView&lt;/code&gt; and bind it to the &lt;code class=&quot;highlighter-rouge&quot;&gt;isRegistering&lt;/code&gt; property.&lt;/p&gt;

&lt;p&gt;To achieve bindablity on a &lt;code class=&quot;highlighter-rouge&quot;&gt;UIActivityIndicatorView&lt;/code&gt; we need to add the following to the &lt;code class=&quot;highlighter-rouge&quot;&gt;Util.swift&lt;/code&gt; file:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension UIActivityIndicatorView {
    public var rac_animating: MutableProperty&amp;lt;Bool&amp;gt; {
        return lazyMutableProperty(self, key: &amp;amp;AssociationKey.animated, setter: { if $0 { self.startAnimating() } else { self.stopAnimating() } }, getter: { self.isAnimating() })
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Expanding the test would look like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func testAPICall() {
    
    let registerService = RegisterService(urlSession: NSURLSession.sharedSession())
    let registerViewModel = RegisterViewModel(registerService: registerService)
    let registerButton = UIButton()
    let usernameTextField = UITextField()
    let passwordTextField = UITextField()
    
    registerViewModel.username &amp;lt;~ usernameTextField.rac_text
    registerViewModel.password &amp;lt;~ passwordTextField.rac_text
    registerButton.rac_enabled &amp;lt;~ registerViewModel.registerEnabledSignalProducer

    XCTAssertFalse(registerButton.enabled)
    
    usernameTextField.inputText(&quot;mariano@zerously.com&quot;)
    
    XCTAssertFalse(registerButton.enabled)
    
    passwordTextField.inputText(&quot;pa55worD&quot;)
    
    XCTAssertTrue(registerButton.enabled)
    
    let activityIndicatorView = UIActivityIndicatorView()
    let errorLabel = UILabel()
    
    errorLabel.rac_text &amp;lt;~ registerViewModel.registryError
    activityIndicatorView.rac_animating &amp;lt;~ registerViewModel.isRegistering
    
    let expectation = expectationWithDescription(&quot;Wait for register to return&quot;)

    registerViewModel.register().observeCompleted {

        XCTAssertTrue(registerButton.enabled)
        XCTAssertFalse(activityIndicatorView.isAnimating())

        // On a View Controller, we&#39;d probably move to the onboarding screen.
        // Since this is a test, we&#39;ll simply mark the expectation as fulfilled.
        expectation.fulfill()
    }
    
    XCTAssertFalse(registerButton.enabled)
    XCTAssertTrue(activityIndicatorView.isAnimating())
    
    waitForExpectationsWithTimeout(10) { (error) in
        
        if error != nil {

            XCTFail()
        }
    }
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And this is how the expanded &lt;code class=&quot;highlighter-rouge&quot;&gt;register&lt;/code&gt; fuction would look like:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func register() -&amp;gt; Signal&amp;lt;Void, NoError&amp;gt; {

    var didRegisterSink: Observer&amp;lt;Void, NoError&amp;gt;?
    let didRegisterSignal = Signal&amp;lt;Void, NoError&amp;gt; { (sink) -&amp;gt; Disposable? in
        
        didRegisterSink = sink
        return nil
    }
    
    guard let username = self.username.value,
                password = self.password.value else {

            self.registryError.value = &quot;Invalid username or password&quot;
            self.isRegistering.value = false
            
            return didRegisterSignal
    }

    self.isRegistering.value = true

    self.registerService.register(username: username, password: password)
        .map { (data, urlResponse) -&amp;gt; String? in
    
            self.isRegistering.value = false
            
            if let responseDictionary = try? NSJSONSerialization.JSONObjectWithData(data, options: .MutableLeaves) as! [String: AnyObject] {
                
                return responseDictionary[&quot;token&quot;] as? String
                
            } else {
                
                return nil
            }
        }
        .mapError { (error) -&amp;gt; NSError in

            self.registryError.value = error.userInfo[&quot;Reason&quot;] as? String
            self.isRegistering.value = false

            return error
        }
        .observeOn(UIScheduler())
        .startWithNext { (token) in

            if let token = token {
                
                // Let&#39;s assume that the token should go into some sort of
                // local authentication store for later use.
                print(token)
                
                self.isRegistering.value = false
                didRegisterSink?.sendCompleted()
                
            } else {
                
                self.registryError.value = &quot;Invalid token&quot;
                self.isRegistering.value = false
            }
    }
    
    return didRegisterSignal
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This exemplifies non-trivial usage of mapping, chanining, binding and signal creation. Just like &lt;code class=&quot;highlighter-rouge&quot;&gt;observeNext&lt;/code&gt; is triggered when the observer does a &lt;code class=&quot;highlighter-rouge&quot;&gt;sendNext&lt;/code&gt;, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt; transforms the data a &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt; sends, the &lt;code class=&quot;highlighter-rouge&quot;&gt;mapError&lt;/code&gt; transforms the data a &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt; sends when there’s been an error.&lt;/p&gt;

&lt;h1 id=&quot;testing-error-handling&quot;&gt;Testing Error handling&lt;/h1&gt;

&lt;p&gt;Our tests didn’t include the error handling, so let’s make sure that works as we expect. For doing so, we’ll need our RegisterService to fail, in a few different ways.&lt;/p&gt;

&lt;p&gt;Luckily we already are injecting the RegisterService and we can choose to inject a failing RegisterService instead.&lt;/p&gt;

&lt;p&gt;To achieve that, we’ll need to standardize the &lt;code class=&quot;highlighter-rouge&quot;&gt;RegisterService&lt;/code&gt; the ViewModel uses into a protocol:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol RegisterServiceProtocol {
    
    func register(username username: String, password: String) -&amp;gt; SignalProducer&amp;lt;(NSData, NSURLResponse), NSError&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Have &lt;code class=&quot;highlighter-rouge&quot;&gt;RegisterService&lt;/code&gt; inherite from it:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct RegisterService: RegisterServiceProtocol {

	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And have the &lt;code class=&quot;highlighter-rouge&quot;&gt;RegisterViewModel&lt;/code&gt; taking that as a valid initializer:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct RegisterViewModel {
    
    let registerService: RegisterServiceProtocol

    init(registerService: RegisterServiceProtocol) {

        self.registerService = registerService
        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Our tests should still be passing, but they aren’t considering any failure. Let’s create a new test that will address that. Notice that we are using the &lt;code class=&quot;highlighter-rouge&quot;&gt;NoTokenRegisterService&lt;/code&gt; this time, to force an issue and test how we handle it.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func testAPICallDataFailure() {
    
    let registerService = NoTokenRegisterService(urlSession: NSURLSession.sharedSession())
    let registerViewModel = RegisterViewModel(registerService: registerService)
    let registerButton = UIButton()
    let usernameTextField = UITextField()
    let passwordTextField = UITextField()
    
    registerViewModel.username &amp;lt;~ usernameTextField.rac_text
    registerViewModel.password &amp;lt;~ passwordTextField.rac_text
    registerButton.rac_enabled &amp;lt;~ registerViewModel.registerEnabledSignalProducer

    usernameTextField.inputText(&quot;mariano@zerously.com&quot;)
    passwordTextField.inputText(&quot;pa55worD&quot;)

    let activityIndicatorView = UIActivityIndicatorView()
    let errorLabel = UILabel()
    
    errorLabel.rac_text &amp;lt;~ registerViewModel.registryError
    activityIndicatorView.rac_animating &amp;lt;~ registerViewModel.isRegistering
    
    registerViewModel.register().observeCompleted {

        XCTFail(&quot;Should fail and not call sendCompleted&quot;)
    }
    
    XCTAssertTrue(registerButton.enabled)
    XCTAssertFalse(activityIndicatorView.isAnimating())
    XCTAssertEqual(errorLabel.text, &quot;Invalid token&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Here’s the NoTokenRegisterService code:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct NoTokenRegisterService: RegisterServiceProtocol {

    private let urlSession: NSURLSession
    
    init(urlSession: NSURLSession) {
        
        self.urlSession = urlSession
    }

    func register(username username: String, password: String) -&amp;gt; SignalProducer&amp;lt;(NSData, NSURLResponse), NSError&amp;gt; {
        
        let signalProducer = SignalProducer&amp;lt;(NSData, NSURLResponse), NSError&amp;gt; { (sink, compositeDisposable) in
            
            let data = try! NSJSONSerialization.dataWithJSONObject([&quot;Hello&quot;: &quot;No Token Here&quot;], options: .PrettyPrinted)
            let urlResponse = NSURLResponse()
            
            sink.sendNext((data, urlResponse))
        }
        
        return signalProducer
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And here’s the &lt;code class=&quot;highlighter-rouge&quot;&gt;ErrorRegisterService&lt;/code&gt; and its test:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct ErrorRegisterService: RegisterServiceProtocol {
    
    private let urlSession: NSURLSession
    
    init(urlSession: NSURLSession) {
        
        self.urlSession = urlSession
    }
    
    func register(username username: String, password: String) -&amp;gt; SignalProducer&amp;lt;(NSData, NSURLResponse), NSError&amp;gt; {
        
        return SignalProducer&amp;lt;(NSData, NSURLResponse), NSError&amp;gt;(error: NSError(domain: &quot;RegisterService&quot;, code: -1, userInfo: [&quot;Reason&quot;: &quot;Dunno.&quot;]))
    }
}

class ReactiveTests: XCTestCase {
    
    func testAPICallError() {
        
        let registerService = ErrorRegisterService(urlSession: NSURLSession.sharedSession())
        let registerViewModel = RegisterViewModel(registerService: registerService)
        let registerButton = UIButton()
        let usernameTextField = UITextField()
        let passwordTextField = UITextField()
        
        registerViewModel.username &amp;lt;~ usernameTextField.rac_text
        registerViewModel.password &amp;lt;~ passwordTextField.rac_text
        registerButton.rac_enabled &amp;lt;~ registerViewModel.registerEnabledSignalProducer
        
        usernameTextField.inputText(&quot;mariano@zerously.com&quot;)
        passwordTextField.inputText(&quot;pa55worD&quot;)
        
        let activityIndicatorView = UIActivityIndicatorView()
        let errorLabel = UILabel()
        
        errorLabel.rac_text &amp;lt;~ registerViewModel.registryError
        activityIndicatorView.rac_animating &amp;lt;~ registerViewModel.isRegistering
        
        registerViewModel.register().observeCompleted {
            
            XCTFail(&quot;Should fail and not call sendCompleted&quot;)
        }
        
        XCTAssertTrue(registerButton.enabled)
        XCTAssertFalse(activityIndicatorView.isAnimating())
        XCTAssertEqual(errorLabel.text, &quot;Dunno.&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is all great. We have things working the way we want, and reasonable test coverage. Shall we move this into a ViewController and see how it looks on an app rather than on tests?&lt;/p&gt;

&lt;h1 id=&quot;next&quot;&gt;Next&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;/2016/04/03/introduction-to-frp-pt4.html&quot;&gt;Part 4&lt;/a&gt;: Using ReactiveCocoa 4 on an app.&lt;/p&gt;
</description>
        <pubDate>Sun, 03 Apr 2016 10:22:32 -0300</pubDate>
        <link>http://zerously.com/2016/04/03/introduction-to-frp-pt3.html</link>
        <guid isPermaLink="true">http://zerously.com/2016/04/03/introduction-to-frp-pt3.html</guid>
        
        
      </item>
    
      <item>
        <title>Introduction to FRP (part 2)</title>
        <description>&lt;p&gt;This is the second part of the Introduction to FRP series. Here’s the &lt;a href=&quot;/2016/03/20/introduction-to-frp-pt1.html&quot;&gt;first&lt;/a&gt; part.&lt;/p&gt;

&lt;p&gt;As mentioned on the first part of this series, we are going to focus on ReactiveCocoa 4 for showing examples on how to implement FRP concepts. I’ll assume you already installed it on your project. If you haven’t you may want to read &lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa#getting-started&quot;&gt;this&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s use the example of the register button that will be enabled when both the username and the password are valid, as long as the register button hasn’t been pressed already and we are registering the user via API.&lt;/p&gt;

&lt;p&gt;If you recall, this is what we’ve said:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Now, this is what FRP programming will normally do:&lt;br /&gt;
1. &lt;strong&gt;Bind&lt;/strong&gt; the register button’s enabled property to when both the username and the password are valid, as long as the register button hasn’t been pressed already and we aren’t registering the user via API.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So let start with the bind.&lt;/p&gt;

&lt;h1 id=&quot;bindings&quot;&gt;Bindings&lt;/h1&gt;

&lt;p&gt;ReactiveCocoa has a really cool, smart and practical way of binding things via the use of the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;~&lt;/code&gt; operator. Let’s see an example.&lt;/p&gt;

&lt;p&gt;Let’s assume we have a &lt;code class=&quot;highlighter-rouge&quot;&gt;UserViewModel&lt;/code&gt; that looks more less like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class UserViewModel {

	var name = MutableProperty&amp;lt;String?&amp;gt;(nil)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then, this test would pass without issues:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ReactiveTests: XCTestCase {
    
    func testSimpleBind() {
        
        let newName = &quot;Mariano Abdala&quot;
        let userViewModel = UserViewModel()
        let nameBindedProperty = MutableProperty&amp;lt;String?&amp;gt;(nil)
        
        nameBindedProperty &amp;lt;~ userViewModel.name

        userViewModel.name.value = newName

        XCTAssertEqual(userViewModel.name.value, newName)
        XCTAssertEqual(nameBindedProperty.value, newName)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We will, of course, want to bind a &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt; to a &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;’s property. In this case, the user’s name would probably end up being bounded to a &lt;code class=&quot;highlighter-rouge&quot;&gt;userNameLabel&lt;/code&gt;’s &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the past you’d do something like&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RAC(self.userNameLabel, text) = userViewModel.name;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But that won’t work in RAC 4. In RAC 4 you can only bind, using the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;~&lt;/code&gt; operator, to a &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableProperty&amp;lt;T&amp;gt;&lt;/code&gt;. But worry not, because &lt;a href=&quot;http://blog.scottlogic.com/ceberhardt/&quot;&gt;Colin Eberhardt&lt;/a&gt; came up with an &lt;a href=&quot;https://github.com/ColinEberhardt/ReactiveTwitterSearch/blob/master/ReactiveTwitterSearch/Util/UIKitExtensions.swift&quot;&gt;easy way&lt;/a&gt; to turn almost any property (including &lt;code class=&quot;highlighter-rouge&quot;&gt;UIKit&lt;/code&gt;’s) into a RAC 4 &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableProperty&amp;lt;T&amp;gt;&lt;/code&gt;. You’ll most likely want to add that file&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; to any project that uses RAC 4.&lt;/p&gt;

&lt;p&gt;Let’s see how this looks like with a &lt;code class=&quot;highlighter-rouge&quot;&gt;UILabel&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ReactiveTests: XCTestCase {
    
    func testLabelBind() {
        
        let newName = &quot;Mariano Abdala&quot;
        let userViewModel = UserViewModel()
        let userNameLabel = UILabel()
        
        userNameLabel.rac_text &amp;lt;~ userViewModel.name

        userViewModel.name.value = newName

        XCTAssertEqual(userViewModel.name.value, newName)
        XCTAssertEqual(userNameLabel.text, newName)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This may not look like much, but once your View Controllers start looking like just a bunch of simple bindings to your models, that’s when this starts to pay out. And isn’t that what one of the View Controller’s main responsibility is, to bind the View to the Model’s data?&lt;/p&gt;

&lt;p&gt;Let’s then…&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;strong&gt;Bind the register button’s enabled property to when both the username and the password are valid&lt;/strong&gt;, as long as the register button hasn’t been pressed already and we aren’t registering the user via API.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is going to take a few steps, we’ll need to cover hot and cold signals, signal aggregation, transformations and chaining (!), so hang tight.&lt;/p&gt;

&lt;h1 id=&quot;signal-transformations&quot;&gt;Signal transformations&lt;/h1&gt;
&lt;p&gt;The easiest way to validate that the username, or the password or any other text, are valid is via a transformation. We will transform the user name text into a &lt;code class=&quot;highlighter-rouge&quot;&gt;Bool&lt;/code&gt; that will indicate whether the username is valid or not.&lt;/p&gt;

&lt;p&gt;To do that we need a signal. Luckily, all &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableProperty&amp;lt;T&amp;gt;&lt;/code&gt; have one. The prefered method to transform one thing into another is &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We won’t be covering all other transformations, but what’s important is that RAC 4 &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt;’s &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt; doesn’t return a new value, but a new &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt;. Which allows us to do both, biding &lt;em&gt;and&lt;/em&gt; chaining.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ReactiveTests: XCTestCase {
    
    func testCompoundBind() {
        
        let registerButton = UIButton()
        let usernameTextField = UITextField()
        
        registerButton.rac_enabled &amp;lt;~ usernameTextField.rac_text.signal.map { (text) -&amp;gt; Bool in
            
            return text.characters.count &amp;gt;= 8
        }

        XCTAssertFalse(registerButton.enabled)

        usernameTextField.text = &quot;mariano@zerously.com&quot;
        usernameTextField.sendActionsForControlEvents(.EditingChanged)
        
        XCTAssertTrue(registerButton.enabled)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As you can see here, what we are doing is mapping the text of the username to whether it’s valid or not. This is what we meant by a stream being &lt;em&gt;a river with all it’s water&lt;/em&gt;: we can fully define whether the register button is enabled or not, across time and across values.&lt;/p&gt;

&lt;p&gt;There’s a couple new concepts in this test though.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;usernameTextField.sendActionsForControlEvents(.EditingChanged)&lt;/code&gt; is there so that the proper event’s will be triggered when setting the text by hand. You won’t have to worry about this with a live &lt;code class=&quot;highlighter-rouge&quot;&gt;UITextField&lt;/code&gt; on a &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;For the sake of clariry, let’s wrap that into an &lt;code class=&quot;highlighter-rouge&quot;&gt;extension&lt;/code&gt; and assume it’s present in future code.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension UITextField {
    
    func inputText(text: String) {
        
        self.text = text
        self.sendActionsForControlEvents(.EditingChanged)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And then there’s the &lt;code class=&quot;highlighter-rouge&quot;&gt;rac_enabled&lt;/code&gt; property that isn’t present on the &lt;code class=&quot;highlighter-rouge&quot;&gt;Util.swift&lt;/code&gt; file we mentioned before.&lt;/p&gt;

&lt;p&gt;To add new &lt;code class=&quot;highlighter-rouge&quot;&gt;UIKit&lt;/code&gt; properties simply add to that file something like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension UIControl {
    public var rac_enabled: MutableProperty&amp;lt;Bool&amp;gt; {
        return lazyMutableProperty(self, key: &amp;amp;AssociationKey.enabled, setter: { self.enabled = $0 }, getter: { self.enabled })
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But there’s one last a catch here. This test will fail on the first assert. Which brings us to hot and cold signals.&lt;/p&gt;

&lt;h1 id=&quot;hot-and-cold-signals&quot;&gt;Hot and cold signals&lt;/h1&gt;
&lt;p&gt;So, why did that test fail on the first assert?&lt;/p&gt;

&lt;p&gt;Since we were using a hot signal, the binding will only be set once the value of the textfield changes for the first time. Remember that:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you get the current value (which was set in the past) alongside with whichever new values are set in the future binded into your property then you are using a &lt;strong&gt;cold signal&lt;/strong&gt;.&lt;br /&gt;
If you only start getting the new values (whichever are set in the future) binded into your property then you are using a &lt;strong&gt;hot signal&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In this particular case, if we want the enabled to be “computed” false, we need to consider the preexisting username text value, which is &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;How do we get a cold signal? Using the property’s &lt;code class=&quot;highlighter-rouge&quot;&gt;SignalProducer&lt;/code&gt; instead of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt;. It’s that easy.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ReactiveTests: XCTestCase {

    func testCompoundBind() {
        
        let registerButton = UIButton()
        let userNameTextField = UITextField()
        
        registerButton.rac_enabled &amp;lt;~ userNameTextField.rac_text.producer.map { (text) -&amp;gt; Bool in
            
            return text.characters.count &amp;gt;= 8
        }

        XCTAssertFalse(registerButton.enabled)
        userNameTextField.inputText(&quot;mariano@zerously.com&quot;)
        XCTAssertTrue(registerButton.enabled)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;All tests passing, now we need to validate the password as well, how do we do that?&lt;/p&gt;

&lt;h1 id=&quot;signal-aggregation&quot;&gt;Signal Aggregation&lt;/h1&gt;

&lt;p&gt;Have you noticed the name of the test? Exactly, “compound”, what we need to do is combine both signals, the username’s and the password’s.&lt;/p&gt;

&lt;p&gt;And here we go, we have the first part of the goal resolved.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ReactiveTests: XCTestCase {

    func testCompoundBind() {
        
        let registerButton = UIButton()
        let usernameTextField = UITextField()
        let passwordTextField = UITextField()
        
        registerButton.rac_enabled &amp;lt;~
            combineLatest(usernameTextField.rac_text.producer, passwordTextField.rac_text.producer)
            .map { (username, password) -&amp;gt; Bool in
            
	            return username.characters.count &amp;gt;= 8 &amp;amp;&amp;amp;
	                    password.characters.count &amp;gt;= 8
            }

        XCTAssertFalse(registerButton.enabled)
        usernameTextField.inputText(&quot;mariano@zerously.com&quot;)
        XCTAssertFalse(registerButton.enabled)
        passwordTextField.inputText(&quot;pa55worD&quot;)
        XCTAssertTrue(registerButton.enabled)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I’m sure you used apps with &lt;a href=&quot;https://www.reddit.com/r/Jokes/comments/1v4bpa/passwords/&quot;&gt;way more creative algorithms&lt;/a&gt;. ;-)&lt;/p&gt;

&lt;p&gt;There are other kinds of signal aggregation and operations, but we aren’t going to cover that here.&lt;/p&gt;

&lt;h1 id=&quot;chaining&quot;&gt;Chaining&lt;/h1&gt;
&lt;p&gt;While we were dealing with our goal of enabling the register button when both the username and the password are valid, we were unadvertedly using chaining already. &lt;code class=&quot;highlighter-rouge&quot;&gt;combineLatest&lt;/code&gt; returns a &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt; (or &lt;code class=&quot;highlighter-rouge&quot;&gt;SignalProducer&lt;/code&gt;) to which we can perform other transformations (like mapping) and that’s exactly what chaining is all about.&lt;/p&gt;

&lt;p&gt;But, this is awful, shall we move this into a View Model?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct RegisterViewModel {
    
    let username = MutableProperty&amp;lt;String?&amp;gt;(nil)
    let password = MutableProperty&amp;lt;String?&amp;gt;(nil)
    let registerEnabledSignalProducer: SignalProducer&amp;lt;Bool, NoError&amp;gt;
    
    init() {

        self.registerEnabledSignalProducer = combineLatest(self.username.producer, self.password.producer)
            .map { (username, password) -&amp;gt; Bool in

                return username?.characters.count &amp;gt;= 8 &amp;amp;&amp;amp;
                        password?.characters.count &amp;gt;= 8
            }
    }
}

class ReactiveTests: XCTestCase {
    
    func testModelBind() {
        
        let registerViewModel = RegisterViewModel()
        let registerButton = UIButton()
        let usernameTextField = UITextField()
        let passwordTextField = UITextField()
        
        registerViewModel.username &amp;lt;~ usernameTextField.rac_text
        registerViewModel.password &amp;lt;~ passwordTextField.rac_text
        registerButton.rac_enabled &amp;lt;~ registerViewModel.registerEnabledSignalProducer

        XCTAssertFalse(registerButton.enabled)
        usernameTextField.inputText(&quot;mariano@zerously.com&quot;)
        XCTAssertFalse(registerButton.enabled)
        passwordTextField.inputText(&quot;pa55worD&quot;)
        XCTAssertTrue(registerButton.enabled)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;That’s better!&lt;/strong&gt; See how all our code starts looking like simple bindings?&lt;/p&gt;

&lt;h1 id=&quot;next&quot;&gt;Next&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;/2016/04/03/introduction-to-frp-pt3.html&quot;&gt;Part 3&lt;/a&gt;: Applied networking with ReactiveCocoa 4.&lt;br /&gt;
&lt;a href=&quot;/2016/04/03/introduction-to-frp-pt4.html&quot;&gt;Part 4&lt;/a&gt;: Using ReactiveCocoa 4 on an app.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Notice that this is Objc. RAC 4 is mostly built around Swift. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;If you do that, I’d suggest that you change the &lt;code class=&quot;highlighter-rouge&quot;&gt;rac_text&lt;/code&gt; type to &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableProperty&amp;lt;String?&amp;gt;&lt;/code&gt;. Since that’s the type of &lt;code class=&quot;highlighter-rouge&quot;&gt;UILabel&lt;/code&gt;’s text property, so should be the type of the &lt;code class=&quot;highlighter-rouge&quot;&gt;rac_text&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableProperty&lt;/code&gt;. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 24 Mar 2016 21:26:45 -0300</pubDate>
        <link>http://zerously.com/2016/03/24/introduction-to-frp-pt2.html</link>
        <guid isPermaLink="true">http://zerously.com/2016/03/24/introduction-to-frp-pt2.html</guid>
        
        
      </item>
    
      <item>
        <title>Introduction to FRP (part 1)</title>
        <description>&lt;p&gt;Not long ago, I started working on a project that is built around &lt;em&gt;Functional Reactive Programming&lt;/em&gt;. Even with a strong programming background I found it hard at first to even grasp its most fundamental concepts. To make things worst, just as I was starting, &lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot;&gt;ReactiveCocoa&lt;/a&gt; 4 -the FRP framework of choice for said project- was launched with &lt;strong&gt;major&lt;/strong&gt; changes, making it really hard to find good reference material. The ones I found were mostly about making a transition from &lt;code class=&quot;highlighter-rouge&quot;&gt;2.5&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;4.0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here goes some key lessons I learnt the hard way, in the hope that someone in a similar situation as me will find it useful or someone who knows more will correct me if I’m wrong in my understanding of FRP under ReactiveCocoa.&lt;/p&gt;

&lt;h2 id=&quot;frp&quot;&gt;FRP&lt;/h2&gt;
&lt;p&gt;Funcional Reactive Programming is a programming paradigm like many others. The main result of its adoption is more readable code via the sustitution of state by higher level instructions.&lt;/p&gt;

&lt;p&gt;The most common example for state is a register button that will be enabled when both the username and the password are valid, as long as the register button hasn’t been pressed already and we are registering the user via API.&lt;/p&gt;

&lt;p&gt;What imperative programming will normally do is:&lt;br /&gt;
1. Hook into the textfields’ &lt;code class=&quot;highlighter-rouge&quot;&gt;shouldChangeCharactersInRange:replacementString:&lt;/code&gt; delegate method.&lt;br /&gt;
2. Every time the text changes, check whether it’s valid or not.&lt;br /&gt;
3. Check if the counterpart textfield’s text is valid.&lt;br /&gt;
4. Check the &lt;code class=&quot;highlighter-rouge&quot;&gt;isRegistering&lt;/code&gt; property is &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.&lt;br /&gt;
5. Enable the register button.&lt;br /&gt;
6. Hook into the register button &lt;code class=&quot;highlighter-rouge&quot;&gt;UIControlEventTouchUpInside&lt;/code&gt; event.&lt;br /&gt;
7. When the register button is tapped collect the username and password values, call the register API and set the &lt;code class=&quot;highlighter-rouge&quot;&gt;isRegistering&lt;/code&gt; property to &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, this is what FRP programming will normally do:&lt;br /&gt;
1. Bind the register button’s enabled property to &lt;em&gt;when both the username and the password are valid, as long as the register button hasn’t been pressed already and we aren’t registering the user via API&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;It sounds like I’m just repeating myself but that’s exactly what FRP lets you do, define each component’s behaviour in a very similar way to which you think about behaviour.&lt;/p&gt;

&lt;p&gt;A different way to think about this is a spreadsheet. All a spreadsheet needs from the user is that each cell has either values or formulas. If a cell’s formula is &lt;code class=&quot;highlighter-rouge&quot;&gt;=A1+(AVG(B1:B10))&lt;/code&gt; you don’t care about how or when you get the result. You can focus on &lt;em&gt;the formula&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This has two main benefits:&lt;br /&gt;
1. You write code in the same way as you think of it, as previously mentioned.&lt;br /&gt;
2. Once the code is written, the behaviour is contained and complete in a few lines of code. Could be more -much more-, but it’ll be all at one place.&lt;/p&gt;

&lt;p&gt;Let’s go over the components in FRP that will enable us to do such a thing.&lt;/p&gt;

&lt;h1 id=&quot;stream&quot;&gt;Stream&lt;/h1&gt;
&lt;p&gt;A &lt;em&gt;cell&lt;/em&gt; in FRP is called a “Stream”.&lt;/p&gt;

&lt;p&gt;You can think of a stream as the history, past, present and future of a property in the sense that they are self contained and inmutable in time; like a river with all it’s water, but you are seeing just one part of it.&lt;/p&gt;

&lt;p&gt;What triggers the river to move? Events.&lt;/p&gt;

&lt;p&gt;Those events are mostly changes, like temperature was 21º and now it’s 25º but could also be something like finishing serving a customer and wanting the next to come to the counter.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: Streams are often called or represented by Signals, which is a terrible name since they get easily confused with events. You could think of a signal as a semaphore’s light changing&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; from green to red, but in FRP a signal is the semaphore itself.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;bindings&quot;&gt;Bindings&lt;/h1&gt;
&lt;p&gt;What’s the use of a stream if we can’t bind it somewhere?&lt;/p&gt;

&lt;p&gt;What can we bind to a stream? Almost any property, and you know what’s cool? FRP Properties have streams themselves. So you can bind a stream into a property and another property to the first property’s stream.&lt;/p&gt;

&lt;h1 id=&quot;tranformations&quot;&gt;Tranformations&lt;/h1&gt;
&lt;p&gt;A big component of FRP is transformations, they are the &lt;em&gt;formula&lt;/em&gt; in our cell.&lt;/p&gt;

&lt;p&gt;We may have a stream of &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;s but need to bind them to a &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; property, for instance, enabling a button if a property’s text is larger than 4 chars.&lt;/p&gt;

&lt;p&gt;Transformations transform streams into streams, not into values.&lt;/p&gt;

&lt;h1 id=&quot;chaining&quot;&gt;Chaining&lt;/h1&gt;
&lt;p&gt;This is the &lt;em&gt;Functional&lt;/em&gt; part in Functional Reactive Programming. And it’s available all accorss frameworks that you can chain as many streams, streams transformations and streams combinations (which is a kind of transformation) as you want.&lt;/p&gt;

&lt;p&gt;If you are comfortable with Functional Programming there’s not much more explanation needed.&lt;/p&gt;

&lt;h1 id=&quot;hot-and-cold-signals&quot;&gt;Hot and Cold signals&lt;/h1&gt;
&lt;p&gt;This is a fairly important difference, ignoring it could trigger lots of issues.&lt;/p&gt;

&lt;p&gt;You’ll find many &lt;em&gt;fancy&lt;/em&gt; and more correct definitions than this one, but the key part is what happens when you bind a stream to a property:&lt;br /&gt;
If you get the current value (which was set in the past) alongside with whichever new values are set in the future binded into your property then you are using a &lt;strong&gt;cold signal&lt;/strong&gt;.&lt;br /&gt;
If you only start getting the new values (whichever are set in the future) binded into your property then you are using a &lt;strong&gt;hot signal&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This also applies to &lt;em&gt;events&lt;/em&gt;. A cold signal could be a bank queue that opens up and right away gets a new customer, if any. Whereas a hot signal could be a catastrophe prevention system, you only want to start the siren when the next warning comes in, regardless of whether there was one in the past.&lt;/p&gt;

&lt;h1 id=&quot;next&quot;&gt;Next&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;/2016/03/24/introduction-to-frp-pt2.html&quot;&gt;Part 2&lt;/a&gt;: How to implement these concepts in ReactiveCocoa 4.&lt;br /&gt;
&lt;a href=&quot;/2016/04/03/introduction-to-frp-pt3.html&quot;&gt;Part 3&lt;/a&gt;: Applied networking with ReactiveCocoa 4.&lt;br /&gt;
&lt;a href=&quot;/2016/04/03/introduction-to-frp-pt4.html&quot;&gt;Part 4&lt;/a&gt;: Using ReactiveCocoa 4 on an app.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;New Oxford American Dictionary: &lt;strong&gt;signal&lt;/strong&gt; |ˈsiɡnəl| (noun) • an event or statement that provides the impulse or occasion for something specified to happen: the champion’s announcement that he was retiring was the signal for scores of journalists to gather at his last match. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 20 Mar 2016 11:33:20 -0300</pubDate>
        <link>http://zerously.com/2016/03/20/introduction-to-frp-pt1.html</link>
        <guid isPermaLink="true">http://zerously.com/2016/03/20/introduction-to-frp-pt1.html</guid>
        
        
      </item>
    
      <item>
        <title>Hello</title>
        <description>&lt;p&gt;I know, I know. I shouldn’t be switching my blog’s url and name so often.&lt;/p&gt;

&lt;p&gt;But Tumblr wasn’t doing such a great job at hosting my posts… and I just decided I’d go lean with &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt; and &lt;a href=&quot;https://pages.github.com&quot;&gt;Github Pages&lt;/a&gt;, start over, hell, &lt;em&gt;why not&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;You can find my previous writings here:&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com&quot;&gt;mariano.zerously.com&lt;/a&gt; (2013-2015)&lt;br /&gt;
&lt;a href=&quot;http://mythirdblog.wordpress.com&quot;&gt;mythirdblog&lt;/a&gt; (2007-2010)&lt;/p&gt;

&lt;p&gt;I tried importing them, redirecting them, renaming them and honestly, it isn’t wasn’t worth it.&lt;/p&gt;

&lt;p&gt;I’ll save you some time, here are my &lt;strong&gt;favorite posts&lt;/strong&gt; from my past blogs:&lt;br /&gt;
&lt;a href=&quot;https://mythirdblog.wordpress.com/2009/04/25/planning-to-get-rid-of-my-pc/&quot;&gt;Planning to get rid of my PC&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://mythirdblog.wordpress.com/2009/11/18/5-phases-to-become-a-happy-programer/&quot;&gt;5 phases to become a happy programmer&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/18906826372/ios-push-notifications-sends-user-untraceable&quot;&gt;iOS push notifications sends user-untraceable sounds&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/20670689934/keeping-badges-updated&quot;&gt;Keeping badges updated&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/31202489835/just-this&quot;&gt;Just this&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/57244969720/a-proposed-technique-for-offering-users-assistance&quot;&gt;A proposed technique for offering users assistance in the event of a crash&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/57612023714/best-tool-for-making-difficult-decisions&quot;&gt;Best tool for making difficult decisions&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/66670579060/hosting-an-nscoder&quot;&gt;Hosting an NSCoder&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/67763971947/best-desktop-ive-ever-had&quot;&gt;Best desktop I’ve ever had&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/88906173465/best-desktop-ive-ever-had-yet&quot;&gt;Best desktop I’ve ever had, yet&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Have fun.&lt;/p&gt;
</description>
        <pubDate>Sat, 19 Mar 2016 18:59:52 -0300</pubDate>
        <link>http://zerously.com/2016/03/19/hello.html</link>
        <guid isPermaLink="true">http://zerously.com/2016/03/19/hello.html</guid>
        
        
      </item>
    
  </channel>
</rss>
