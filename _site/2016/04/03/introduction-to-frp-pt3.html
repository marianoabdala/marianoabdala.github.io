<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Introduction to FRP (part 3)</title>
  <meta name="description" content="This is the third part of the Introduction to FRP series. Here’s the first and second parts.">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://zerously.com/2016/04/03/introduction-to-frp-pt3.html">
  <link rel="alternate" type="application/rss+xml" title="Mariano Abdala" href="http://zerously.com/feed.xml">

  <link rel="icon" type="image/png" href="/images/favicon_32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/images/favicon_16.png" sizes="16x16" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Mariano Abdala</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Introduction to FRP (part 3)</h1>
    <p class="post-meta"><time datetime="2016-04-03T10:22:32-03:00" itemprop="datePublished">Apr 3, 2016</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>This is the third part of the Introduction to FRP series. Here’s the <a href="/2016/03/20/introduction-to-frp-pt1.html">first</a> and <a href="/2016/03/24/introduction-to-frp-pt2.html">second</a> parts.</p>

<p>Here, we’ll be covering networking. In itself, networking with FRP isn’t a long subject, but it provides us with an excuse to cover many generic FRP concepts that normally happen (and are easier to explain and grasp) when you use it to manage networking.</p>

<p>Let’s pick it up where we left it and focus on the second part of the statement:</p>

<blockquote>
  <ol>
    <li>Bind the register button’s enabled property to when both the username and the password are valid, <strong>as long as the register button hasn’t been pressed already and we aren’t registering the user via API</strong>.</li>
  </ol>
</blockquote>

<p>To achieve this we’ll add a <code class="highlighter-rouge">isRegistering</code> property on the <code class="highlighter-rouge">RegisterViewModel</code> and update the <code class="highlighter-rouge">registerEnabledSignalProducer</code> that drives whether the register button is enabled:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>struct RegisterViewModel {

    let username = MutableProperty&lt;String?&gt;(nil)
    let password = MutableProperty&lt;String?&gt;(nil)
    let registerEnabledSignalProducer: SignalProducer&lt;Bool, NoError&gt;
    let isRegistering = MutableProperty(false)

    init() {

        self.registerEnabledSignalProducer = combineLatest(self.username.producer, self.password.producer, self.isRegistering.producer)
            .map { (username, password, isRegistering) -&gt; Bool in

              return username?.characters.count &gt;= 8 &amp;&amp;
                      password?.characters.count &gt;= 8 &amp;&amp;
                      isRegistering == false
            }
    }
}
</code></pre>
</div>

<p>Now all we need to do is set the value of the <code class="highlighter-rouge">isRegistering</code> property when we call the API and when the API responds. Notice Also that we combined username, password and isRegistering using <code class="highlighter-rouge">combineLatest</code>, which allows us to combine up to 10 <code class="highlighter-rouge">Signal</code>s/<code class="highlighter-rouge">SignalProducer</code>s!!</p>

<p>So, let’s get our hands dirty, shall we? Let’s make and actual API call and handle it, even though <strong>we already covered the original requirements</strong>.</p>

<h1 id="simple-service">Simple Service</h1>

<div class="highlighter-rouge"><pre class="highlight"><code>struct RegisterService {
    
    private let urlSession: NSURLSession
    
    init(urlSession: NSURLSession) {
        
        self.urlSession = urlSession
    }
    
    func register(username username: String, password: String) -&gt; SignalProducer&lt;(NSData, NSURLResponse), NSError&gt; {

        // Let's assume we are inserting username and password to the request.
        guard let url = NSURL(string: "http://zerously.com/misc/register.json") else {
            
            return SignalProducer&lt;(NSData, NSURLResponse), NSError&gt;(error: NSError(domain: "RegisterService", code: -1, userInfo: ["Reason": "Invalid URL."]))
        }
        
        let request = NSURLRequest(URL: url)
        return self.urlSession.rac_dataWithRequest(request)
    }
}
</code></pre>
</div>

<p>The key to this service is that we aren’t returning a value or a model, we are returning a SignalProducer, for the consumer to transform, manage and handle; and ReactiveCocoa has a very handy method to achieve that right of from a <code class="highlighter-rouge">NSURLSession</code>, the <code class="highlighter-rouge">rac_dataWithRequest(_:)</code> method.</p>

<p>For simplicity sake we aren’t adding username and password to the request, but we could verify if they are valid and return a <code class="highlighter-rouge">SignalProducer</code> that will produce an error immediately in a similary way as the one shown in the code, for verifying the URL is valid.</p>

<h1 id="usage-from-the-view-model">Usage from the View Model</h1>

<p>Here’s how a rough call to this would look like from the ViewModel:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>struct RegisterViewModel {

    let registerService: RegisterService

    init(registerService: RegisterService) {

        self.registerService = registerService
        ...
    }

    func register() {

        guard let username = self.username.value,
                    password = self.password.value else {

                return
        }

        self.isRegistering.value = true

        self.registerService.register(username: username, password: password)
            .observeOn(UIScheduler())
            .startWithNext {

                self.isRegistering.value = false
            }
    }
}
</code></pre>
</div>

<p>A few things to note here:</p>

<ul>
  <li>We are injecting the <code class="highlighter-rouge">RegisterService</code> into the ViewModel, we’ll see how that’s useful later.</li>
  <li>We are handling the happy path for the <code class="highlighter-rouge">isRegistering</code> property we created previously.</li>
  <li>We are calling <code class="highlighter-rouge">.observeOn(UIScheduler())</code> to make sure we are working on the main thread from here on since the changes in <code class="highlighter-rouge">isRegistering</code> will affect UI.</li>
</ul>

<p>Seems like we are forgetting something? We aren’t doing anything with the result of the API call! We need to inform the ViewController that we finished registering the user successfully, so…</p>

<div class="highlighter-rouge"><pre class="highlight"><code>func register() -&gt; Bool {

	...
}
</code></pre>
</div>

<p>What? <strong>No!</strong></p>

<p>By now, we know much more expresive and rective ways of doing this… It’ll require us not to consume, but to create a <code class="highlighter-rouge">Signal</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>func register() -&gt; Signal&lt;Void, NoError&gt; {

    var didRegisterSink: Observer&lt;Void, NoError&gt;?
    let didRegisterSignal = Signal&lt;Void, NoError&gt; { (sink) -&gt; Disposable? in
        
        didRegisterSink = sink
        return nil
    }
    
    self.isRegistering.value = true

    self.registerService.register(username: username, password: password)
        .observeOn(UIScheduler())
        .startWithNext {

            self.isRegistering.value = false
            didRegisterSink?.sendCompleted()
    	}
    
    return didRegisterSignal
}
</code></pre>
</div>

<p>So, how does this work?</p>

<p>Every time you create a <code class="highlighter-rouge">Signal</code> or a <code class="highlighter-rouge">SignalProducer</code> you’ll get a <code class="highlighter-rouge">sink</code> that’s going to be the reciever of the events. Just like to <code class="highlighter-rouge">observeNext</code> or <code class="highlighter-rouge">observeCompleted</code> you can <code class="highlighter-rouge">sendNext</code> and <code class="highlighter-rouge">sendCompleted</code> on the other side, on the sink.</p>

<p>We can now bind this to our test.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>func testAPICall() {
    
    let registerService = RegisterService(urlSession: NSURLSession.sharedSession())
    let registerViewModel = RegisterViewModel(registerService: registerService)
    let registerButton = UIButton()
    let usernameTextField = UITextField()
    let passwordTextField = UITextField()
    
    registerViewModel.username &lt;~ usernameTextField.rac_text
    registerViewModel.password &lt;~ passwordTextField.rac_text
    registerButton.rac_enabled &lt;~ registerViewModel.registerEnabledSignalProducer

    XCTAssertFalse(registerButton.enabled)
    
    usernameTextField.inputText("mariano@zerously.com")
    
    XCTAssertFalse(registerButton.enabled)
    
    passwordTextField.inputText("pa55worD")
    
    XCTAssertTrue(registerButton.enabled)
    
    let expectation = expectationWithDescription("Wait for register to return")

    registerViewModel.register().observeCompleted {

        XCTAssertTrue(registerButton.enabled)

        // On a View Controller, we'd probably move to the onboarding screen.
        // Since this is a test, we'll simply mark the expectation as fulfilled.
        expectation.fulfill()
    }
    
    XCTAssertFalse(registerButton.enabled)
    
    waitForExpectationsWithTimeout(10) { (error) in
        
        if error != nil {

            XCTFail()
        }
    }
 }
</code></pre>
</div>

<h1 id="non-trivial-behaviour">Non-trivial behaviour</h1>

<p>As we add non-trivial behaviour to this example, we have to make sure we have errors handled too, so let’s add a <code class="highlighter-rouge">registryError</code> property and bind it in our tests to a <code class="highlighter-rouge">errorLabel</code>. While we are here, let’s add an <code class="highlighter-rouge">activityIndicatorView</code> and bind it to the <code class="highlighter-rouge">isRegistering</code> property.</p>

<p>To achieve bindablity on a <code class="highlighter-rouge">UIActivityIndicatorView</code> we need to add the following to the <code class="highlighter-rouge">Util.swift</code> file:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>extension UIActivityIndicatorView {
    public var rac_animating: MutableProperty&lt;Bool&gt; {
        return lazyMutableProperty(self, key: &amp;AssociationKey.animated, setter: { if $0 { self.startAnimating() } else { self.stopAnimating() } }, getter: { self.isAnimating() })
    }
}
</code></pre>
</div>

<p>Expanding the test would look like this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>func testAPICall() {
    
    let registerService = RegisterService(urlSession: NSURLSession.sharedSession())
    let registerViewModel = RegisterViewModel(registerService: registerService)
    let registerButton = UIButton()
    let usernameTextField = UITextField()
    let passwordTextField = UITextField()
    
    registerViewModel.username &lt;~ usernameTextField.rac_text
    registerViewModel.password &lt;~ passwordTextField.rac_text
    registerButton.rac_enabled &lt;~ registerViewModel.registerEnabledSignalProducer

    XCTAssertFalse(registerButton.enabled)
    
    usernameTextField.inputText("mariano@zerously.com")
    
    XCTAssertFalse(registerButton.enabled)
    
    passwordTextField.inputText("pa55worD")
    
    XCTAssertTrue(registerButton.enabled)
    
    let activityIndicatorView = UIActivityIndicatorView()
    let errorLabel = UILabel()
    
    errorLabel.rac_text &lt;~ registerViewModel.registryError
    activityIndicatorView.rac_animating &lt;~ registerViewModel.isRegistering
    
    let expectation = expectationWithDescription("Wait for register to return")

    registerViewModel.register().observeCompleted {

        XCTAssertTrue(registerButton.enabled)
        XCTAssertFalse(activityIndicatorView.isAnimating())

        // On a View Controller, we'd probably move to the onboarding screen.
        // Since this is a test, we'll simply mark the expectation as fulfilled.
        expectation.fulfill()
    }
    
    XCTAssertFalse(registerButton.enabled)
    XCTAssertTrue(activityIndicatorView.isAnimating())
    
    waitForExpectationsWithTimeout(10) { (error) in
        
        if error != nil {

            XCTFail()
        }
    }
 }
</code></pre>
</div>

<p>And this is how the expanded <code class="highlighter-rouge">register</code> fuction would look like:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>func register() -&gt; Signal&lt;Void, NoError&gt; {

    var didRegisterSink: Observer&lt;Void, NoError&gt;?
    let didRegisterSignal = Signal&lt;Void, NoError&gt; { (sink) -&gt; Disposable? in
        
        didRegisterSink = sink
        return nil
    }
    
    guard let username = self.username.value,
                password = self.password.value else {

            self.registryError.value = "Invalid username or password"
            self.isRegistering.value = false
            
            return didRegisterSignal
    }

    self.isRegistering.value = true

    self.registerService.register(username: username, password: password)
        .map { (data, urlResponse) -&gt; String? in
    
            self.isRegistering.value = false
            
            if let responseDictionary = try? NSJSONSerialization.JSONObjectWithData(data, options: .MutableLeaves) as! [String: AnyObject] {
                
                return responseDictionary["token"] as? String
                
            } else {
                
                return nil
            }
        }
        .mapError { (error) -&gt; NSError in

            self.registryError.value = error.userInfo["Reason"] as? String
            self.isRegistering.value = false

            return error
        }
        .observeOn(UIScheduler())
        .startWithNext { (token) in

            if let token = token {
                
                // Let's assume that the token should go into some sort of
                // local authentication store for later use.
                print(token)
                
                self.isRegistering.value = false
                didRegisterSink?.sendCompleted()
                
            } else {
                
                self.registryError.value = "Invalid token"
                self.isRegistering.value = false
            }
    }
    
    return didRegisterSignal
}
</code></pre>
</div>

<p>This exemplifies non-trivial usage of mapping, chanining, binding and signal creation. Just like <code class="highlighter-rouge">observeNext</code> is triggered when the observer does a <code class="highlighter-rouge">sendNext</code>, and the <code class="highlighter-rouge">map</code> transforms the data a <code class="highlighter-rouge">Signal</code> sends, the <code class="highlighter-rouge">mapError</code> transforms the data a <code class="highlighter-rouge">Signal</code> sends when there’s been an error.</p>

<h1 id="testing-error-handling">Testing Error handling</h1>

<p>Our tests didn’t include the error handling, so let’s make sure that works as we expect. For doing so, we’ll need our RegisterService to fail, in a few different ways.</p>

<p>Luckily we already are injecting the RegisterService and we can choose to inject a failing RegisterService instead.</p>

<p>To achieve that, we’ll need to standardize the <code class="highlighter-rouge">RegisterService</code> the ViewModel uses into a protocol:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>protocol RegisterServiceProtocol {
    
    func register(username username: String, password: String) -&gt; SignalProducer&lt;(NSData, NSURLResponse), NSError&gt;
}
</code></pre>
</div>

<p>Have <code class="highlighter-rouge">RegisterService</code> inherite from it:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>struct RegisterService: RegisterServiceProtocol {

	...
}
</code></pre>
</div>

<p>And have the <code class="highlighter-rouge">RegisterViewModel</code> taking that as a valid initializer:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>struct RegisterViewModel {
    
    let registerService: RegisterServiceProtocol

    init(registerService: RegisterServiceProtocol) {

        self.registerService = registerService
        ...
    }
}
</code></pre>
</div>

<p>Our tests should still be passing, but they aren’t considering any failure. Let’s create a new test that will address that. Notice that we are using the <code class="highlighter-rouge">NoTokenRegisterService</code> this time, to force an issue and test how we handle it.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>func testAPICallDataFailure() {
    
    let registerService = NoTokenRegisterService(urlSession: NSURLSession.sharedSession())
    let registerViewModel = RegisterViewModel(registerService: registerService)
    let registerButton = UIButton()
    let usernameTextField = UITextField()
    let passwordTextField = UITextField()
    
    registerViewModel.username &lt;~ usernameTextField.rac_text
    registerViewModel.password &lt;~ passwordTextField.rac_text
    registerButton.rac_enabled &lt;~ registerViewModel.registerEnabledSignalProducer

    usernameTextField.inputText("mariano@zerously.com")
    passwordTextField.inputText("pa55worD")

    let activityIndicatorView = UIActivityIndicatorView()
    let errorLabel = UILabel()
    
    errorLabel.rac_text &lt;~ registerViewModel.registryError
    activityIndicatorView.rac_animating &lt;~ registerViewModel.isRegistering
    
    registerViewModel.register().observeCompleted {

        XCTFail("Should fail and not call sendCompleted")
    }
    
    XCTAssertTrue(registerButton.enabled)
    XCTAssertFalse(activityIndicatorView.isAnimating())
    XCTAssertEqual(errorLabel.text, "Invalid token")
}
</code></pre>
</div>

<p>Here’s the NoTokenRegisterService code:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>struct NoTokenRegisterService: RegisterServiceProtocol {

    private let urlSession: NSURLSession
    
    init(urlSession: NSURLSession) {
        
        self.urlSession = urlSession
    }

    func register(username username: String, password: String) -&gt; SignalProducer&lt;(NSData, NSURLResponse), NSError&gt; {
        
        let signalProducer = SignalProducer&lt;(NSData, NSURLResponse), NSError&gt; { (sink, compositeDisposable) in
            
            let data = try! NSJSONSerialization.dataWithJSONObject(["Hello": "No Token Here"], options: .PrettyPrinted)
            let urlResponse = NSURLResponse()
            
            sink.sendNext((data, urlResponse))
        }
        
        return signalProducer
    }
}
</code></pre>
</div>

<p>And here’s the <code class="highlighter-rouge">ErrorRegisterService</code> and its test:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>struct ErrorRegisterService: RegisterServiceProtocol {
    
    private let urlSession: NSURLSession
    
    init(urlSession: NSURLSession) {
        
        self.urlSession = urlSession
    }
    
    func register(username username: String, password: String) -&gt; SignalProducer&lt;(NSData, NSURLResponse), NSError&gt; {
        
        return SignalProducer&lt;(NSData, NSURLResponse), NSError&gt;(error: NSError(domain: "RegisterService", code: -1, userInfo: ["Reason": "Dunno."]))
    }
}

class ReactiveTests: XCTestCase {
    
    func testAPICallError() {
        
        let registerService = ErrorRegisterService(urlSession: NSURLSession.sharedSession())
        let registerViewModel = RegisterViewModel(registerService: registerService)
        let registerButton = UIButton()
        let usernameTextField = UITextField()
        let passwordTextField = UITextField()
        
        registerViewModel.username &lt;~ usernameTextField.rac_text
        registerViewModel.password &lt;~ passwordTextField.rac_text
        registerButton.rac_enabled &lt;~ registerViewModel.registerEnabledSignalProducer
        
        usernameTextField.inputText("mariano@zerously.com")
        passwordTextField.inputText("pa55worD")
        
        let activityIndicatorView = UIActivityIndicatorView()
        let errorLabel = UILabel()
        
        errorLabel.rac_text &lt;~ registerViewModel.registryError
        activityIndicatorView.rac_animating &lt;~ registerViewModel.isRegistering
        
        registerViewModel.register().observeCompleted {
            
            XCTFail("Should fail and not call sendCompleted")
        }
        
        XCTAssertTrue(registerButton.enabled)
        XCTAssertFalse(activityIndicatorView.isAnimating())
        XCTAssertEqual(errorLabel.text, "Dunno.")
    }
}
</code></pre>
</div>

<p>This is all great. We have things working the way we want, and reasonable test coverage. Shall we move this into a ViewController and see how it looks on an app rather than on tests?</p>

<h1 id="next">Next</h1>
<p><a href="/2016/04/03/introduction-to-frp-pt4.html">Part 4</a>: Using ReactiveCocoa 4 on an app.</p>

  </div>

</article>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>Mariano Abdala</li>
          <li><a href="mailto:mariano@zerously.com">mariano@zerously.com</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/marianoabdala"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">marianoabdala</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/marianoabdala"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">marianoabdala</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>Writings of Mariano Abdala. iOS Developer, host at <a href="https://twitter.com/nscoderba">@NSCoderBA</a> and organizer at <a href="https://twitter.com/nsconfarg">@NSConfArg</a>.</p>
      </div>
    </div>

  </div>

</footer>


    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-17657932-1', 'auto');
      ga('send', 'pageview');

    </script>
  </body>

</html>
