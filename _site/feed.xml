<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mariano Abdala</title>
    <description>Writings of Mariano Abdala. iOS Developer, host at @NSCoderBA and organizer at @NSConfArg.
</description>
    <link>http://zerously.com/</link>
    <atom:link href="http://zerously.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 25 Mar 2016 11:58:59 -0300</pubDate>
    <lastBuildDate>Fri, 25 Mar 2016 11:58:59 -0300</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>Introduction to FRP (part 2)</title>
        <description>&lt;p&gt;This is the second part of the Introduction to FRP series. Here’s the &lt;a href=&quot;/2016/03/20/introduction-to-frp-pt1.html&quot;&gt;first&lt;/a&gt; part.&lt;/p&gt;

&lt;p&gt;As mentioned on the first part of this series, we are going to focus on ReactiveCocoa 4 for showing examples on how to implement FRP concepts. I’ll assume you already installed it on your project. If you haven’t you may want to read &lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa#getting-started&quot;&gt;this&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s use the example of the register button that will be enabled when both the username and the password are valid, as long as the register button hasn’t been pressed already and we are registering the user via API.&lt;/p&gt;

&lt;p&gt;If you recall, this is what we’ve said:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Now, this is what FRP programming will normally do:&lt;br /&gt;
1. &lt;strong&gt;Bind&lt;/strong&gt; the register button’s enabled property to when both the username and the password are valid, as long as the register button hasn’t been pressed already and we aren’t registering the user via API.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So let start with the bind.&lt;/p&gt;

&lt;h1 id=&quot;bindings&quot;&gt;Bindings&lt;/h1&gt;

&lt;p&gt;ReactiveCocoa has a really cool, smart and practical way of binding things via the use of the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;~&lt;/code&gt; operator. Let’s see an example.&lt;/p&gt;

&lt;p&gt;Let’s assume we have a &lt;code class=&quot;highlighter-rouge&quot;&gt;UserViewModel&lt;/code&gt; that looks more less like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class UserViewModel {

	var name = MutableProperty&amp;lt;String?&amp;gt;(nil)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then, this test would pass without issues:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ReactiveTests: XCTestCase {
    
    func testSimpleBind() {
        
        let newName = &quot;Mariano Abdala&quot;
        let userViewModel = UserViewModel()
        let nameBindedProperty = MutableProperty&amp;lt;String?&amp;gt;(nil)
        
        nameBindedProperty &amp;lt;~ userViewModel.name

        userViewModel.name.value = newName

        XCTAssertEqual(userViewModel.name.value, newName)
        XCTAssertEqual(nameBindedProperty.value, newName)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We will, of course, want to bind a &lt;code class=&quot;highlighter-rouge&quot;&gt;ViewModel&lt;/code&gt; to a &lt;code class=&quot;highlighter-rouge&quot;&gt;UIView&lt;/code&gt;’s property. In this case, the user’s name would probably end up being bounded to a &lt;code class=&quot;highlighter-rouge&quot;&gt;userNameLabel&lt;/code&gt;’s &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In the past you’d do something like&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RAC(self.userNameLabel, text) = userViewModel.name;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But that won’t work in RAC 4. In RAC 4 you can only bind, using the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;~&lt;/code&gt; operator, to a &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableProperty&amp;lt;T&amp;gt;&lt;/code&gt;. But worry not, because &lt;a href=&quot;http://blog.scottlogic.com/ceberhardt/&quot;&gt;Colin Eberhardt&lt;/a&gt; came up with an &lt;a href=&quot;https://github.com/ColinEberhardt/ReactiveTwitterSearch/blob/master/ReactiveTwitterSearch/Util/UIKitExtensions.swift&quot;&gt;easy way&lt;/a&gt; to turn almost any property (including &lt;code class=&quot;highlighter-rouge&quot;&gt;UIKit&lt;/code&gt;’s) into a RAC 4 &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableProperty&amp;lt;T&amp;gt;&lt;/code&gt;. You’ll most likely want to add that file&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; to any project that uses RAC 4.&lt;/p&gt;

&lt;p&gt;Let’s see how this looks like with a &lt;code class=&quot;highlighter-rouge&quot;&gt;UILabel&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ReactiveTests: XCTestCase {
    
    func testLabelBind() {
        
        let newName = &quot;Mariano Abdala&quot;
        let userViewModel = UserViewModel()
        let userNameLabel = UILabel()
        
        userNameLabel.rac_text &amp;lt;~ userViewModel.name

        userViewModel.name.value = newName

        XCTAssertEqual(userViewModel.name.value, newName)
        XCTAssertEqual(userNameLabel.text, newName)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This may not look like much, but once your View Controllers start looking like just a bunch of simple bindings to your models, that’s when this starts to pay out. And isn’t that what one of the View Controller’s main responsibility is, to bind the View to the Model’s data?&lt;/p&gt;

&lt;p&gt;Let’s then…&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;&lt;strong&gt;Bind the register button’s enabled property to when both the username and the password are valid&lt;/strong&gt;, as long as the register button hasn’t been pressed already and we aren’t registering the user via API.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is going to take a few steps, we’ll need to cover hot and cold signals, signal aggregation, transformations and chaining (!), so hang tight.&lt;/p&gt;

&lt;h1 id=&quot;signal-transformations&quot;&gt;Signal transformations&lt;/h1&gt;
&lt;p&gt;The easiest way to validate that the username, or the password or any other text, are valid is via a transformation. We will transform the user name text into a &lt;code class=&quot;highlighter-rouge&quot;&gt;Bool&lt;/code&gt; that will indicate whether the username is valid or not.&lt;/p&gt;

&lt;p&gt;To do that we need a signal. Luckily, all &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableProperty&amp;lt;T&amp;gt;&lt;/code&gt; have one. The prefered method to transform one thing into another is &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We won’t be covering all other transformations, but what’s important is that RAC 4 &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt;’s &lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt; doesn’t return a new value, but a new &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt;. Which allows us to do both, biding &lt;em&gt;and&lt;/em&gt; chaining.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ReactiveTests: XCTestCase {
    
    func testCompoundBind() {
        
        let registerButton = UIButton()
        let usernameTextField = UITextField()
        
        registerButton.rac_enabled &amp;lt;~ usernameTextField.rac_text.signal.map { (text) -&amp;gt; Bool in
            
            return text.characters.count &amp;gt;= 8
        }

        XCTAssertFalse(registerButton.enabled)

        usernameTextField.text = &quot;mariano@zerously.com&quot;
        usernameTextField.sendActionsForControlEvents(.EditingChanged)
        
        XCTAssertTrue(registerButton.enabled)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As you can see here, what we are doing is mapping the text of the username to whether it’s valid or not. This is what we meant by a stream being &lt;em&gt;a river with all it’s water&lt;/em&gt;: we can fully define whether the register button is enabled or not, across time and across values.&lt;/p&gt;

&lt;p&gt;There’s a couple new concepts in this test though.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;usernameTextField.sendActionsForControlEvents(.EditingChanged)&lt;/code&gt; is there so that the proper event’s will be triggered when setting the text by hand. You won’t have to worry about this with a live &lt;code class=&quot;highlighter-rouge&quot;&gt;UITextField&lt;/code&gt; on a &lt;code class=&quot;highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;And then there’s the &lt;code class=&quot;highlighter-rouge&quot;&gt;rac_enabled&lt;/code&gt; property that isn’t present on the &lt;code class=&quot;highlighter-rouge&quot;&gt;Util.swift&lt;/code&gt; file we mentioned before.&lt;/p&gt;

&lt;p&gt;To add new &lt;code class=&quot;highlighter-rouge&quot;&gt;UIKit&lt;/code&gt; properties simply add to that file something like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension UIControl {
    public var rac_enabled: MutableProperty&amp;lt;Bool&amp;gt; {
        return lazyMutableProperty(self, key: &amp;amp;AssociationKey.enabled, setter: { self.enabled = $0 }, getter: { self.enabled })
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;But there’s one last a catch here. This test will fail on the first assert. Which brings us to hot and cold signals.&lt;/p&gt;

&lt;h1 id=&quot;hot-and-cold-signals&quot;&gt;Hot and cold signals&lt;/h1&gt;
&lt;p&gt;So, why did that test fail on the first assert?&lt;/p&gt;

&lt;p&gt;Since we were using a hot signal, the binding will only be set once the value of the textfield changes for the first time. Remember that:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you get the current value (which was set in the past) alongside with whichever new values are set in the future binded into your property then you are using a &lt;strong&gt;cold signal&lt;/strong&gt;.&lt;br /&gt;
If you only start getting the new values (whichever are set in the future) binded into your property then you are using a &lt;strong&gt;hot signal&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In this particular case, if we want the enabled to be “computed” false, we need to consider the preexisting username text value, which is &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;How do we get a cold signal? Using the property’s &lt;code class=&quot;highlighter-rouge&quot;&gt;SignalProducer&lt;/code&gt; instead of the &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt;. It’s that easy.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func testCompoundBind() {
    
    let registerButton = UIButton()
    let userNameTextField = UITextField()
    
    registerButton.rac_enabled &amp;lt;~ userNameTextField.rac_text.producer.map { (text) -&amp;gt; Bool in
        
        return text.characters.count &amp;gt;= 8
    }

    XCTAssertFalse(registerButton.enabled)

    userNameTextField.text = &quot;mariano@zerously.com&quot;
    userNameTextField.sendActionsForControlEvents(.EditingChanged)
    
    XCTAssertTrue(registerButton.enabled)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;All tests passing, now we need to validate the password as well, how do we do that?&lt;/p&gt;

&lt;h1 id=&quot;signal-aggregation&quot;&gt;Signal Aggregation&lt;/h1&gt;

&lt;p&gt;Have you noticed the name of the test? Exactly, “compound”, what we need to do is combine both signals, the username’s and the password’s.&lt;/p&gt;

&lt;p&gt;And here we go, we have the first part of the goal resolved.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;func testCompoundBind() {
    
    let registerButton = UIButton()
    let usernameTextField = UITextField()
    let passwordTextField = UITextField()
    
    registerButton.rac_enabled &amp;lt;~
        combineLatest(usernameTextField.rac_text.producer, passwordTextField.rac_text.producer)
        .map { (username, password) -&amp;gt; Bool in
        
        return username.characters.count &amp;gt;= 8 &amp;amp;&amp;amp;
                password.characters.count &amp;gt;= 8
        }

    XCTAssertFalse(registerButton.enabled)

    usernameTextField.text = &quot;mariano@zerously.com&quot;
    usernameTextField.sendActionsForControlEvents(.EditingChanged)

    XCTAssertFalse(registerButton.enabled)

    passwordTextField.text = &quot;pa55worD&quot;
    passwordTextField.sendActionsForControlEvents(.EditingChanged)
    
    XCTAssertTrue(registerButton.enabled)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I’m sure you used apps with &lt;a href=&quot;https://www.reddit.com/r/Jokes/comments/1v4bpa/passwords/&quot;&gt;way more creative algorithms&lt;/a&gt;. ;-)&lt;/p&gt;

&lt;p&gt;There are other kinds of signal aggregation and operations, but we aren’t going to cover that here.&lt;/p&gt;

&lt;h1 id=&quot;chaining&quot;&gt;Chaining&lt;/h1&gt;
&lt;p&gt;While we were dealing with our goal of enabling the register button when both the username and the password are valid, we were unadvertedly using chaining already. &lt;code class=&quot;highlighter-rouge&quot;&gt;combineLatest&lt;/code&gt; returns a &lt;code class=&quot;highlighter-rouge&quot;&gt;Signal&lt;/code&gt; (or &lt;code class=&quot;highlighter-rouge&quot;&gt;SignalProducer&lt;/code&gt;) to which we can perform other transformations (like mapping) and that’s exactly what chaining is all about.&lt;/p&gt;

&lt;p&gt;But, this is awful, shall we move this into a View Model?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class RegisterViewModel {
    
    let username = MutableProperty&amp;lt;String?&amp;gt;(nil)
    let password = MutableProperty&amp;lt;String?&amp;gt;(nil)
    let registerEnabledSignalProducer: SignalProducer&amp;lt;Bool, NoError&amp;gt;
    
    init() {

        self.registerEnabledSignalProducer = combineLatest(self.username.producer, self.password.producer)
            .map { (username, password) -&amp;gt; Bool in

                return username?.characters.count &amp;gt;= 8 &amp;amp;&amp;amp;
                        password?.characters.count &amp;gt;= 8
            }
    }
}

class ReactiveTests: XCTestCase {
    
    func testModelBind() {
        
        let registerViewModel = RegisterViewModel()
        let registerButton = UIButton()
        let usernameTextField = UITextField()
        let passwordTextField = UITextField()
        
        registerViewModel.username &amp;lt;~ usernameTextField.rac_text
        registerViewModel.password &amp;lt;~ passwordTextField.rac_text
        registerButton.rac_enabled &amp;lt;~ registerViewModel.registerEnabledSignalProducer

        XCTAssertFalse(registerButton.enabled)

        usernameTextField.text = &quot;mariano@zerously.com&quot;
        usernameTextField.sendActionsForControlEvents(.EditingChanged)

        XCTAssertFalse(registerButton.enabled)

        passwordTextField.text = &quot;pa55worD&quot;
        passwordTextField.sendActionsForControlEvents(.EditingChanged)
        
        XCTAssertTrue(registerButton.enabled)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;That’s better!&lt;/strong&gt; See how all our code starts looking like simple bindings?&lt;/p&gt;

&lt;h1 id=&quot;next&quot;&gt;Next&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Part 3 of this series will be coming out soon and it will cover the last part of the goal, binding this to an API service. Stay tuned.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Notice that this is Objc. RAC 4 is mostly built around Swift. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;If you do that, I’d suggest that you change the &lt;code class=&quot;highlighter-rouge&quot;&gt;rac_text&lt;/code&gt; type to &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableProperty&amp;lt;String?&amp;gt;&lt;/code&gt;. Since that’s the type of &lt;code class=&quot;highlighter-rouge&quot;&gt;UILabel&lt;/code&gt;’s text property, so should be the type of the &lt;code class=&quot;highlighter-rouge&quot;&gt;rac_text&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableProperty&lt;/code&gt;. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 24 Mar 2016 21:26:45 -0300</pubDate>
        <link>http://zerously.com/2016/03/24/introduction-to-frp-pt2.html</link>
        <guid isPermaLink="true">http://zerously.com/2016/03/24/introduction-to-frp-pt2.html</guid>
        
        
      </item>
    
      <item>
        <title>Introduction to FRP (part 1)</title>
        <description>&lt;p&gt;Not long ago, I started working on a project that is built around &lt;em&gt;Functional Reactive Programming&lt;/em&gt;. Even with a strong programming background I found it hard at first to even grasp its most fundamental concepts. To make things worst, just as I was starting, &lt;a href=&quot;https://github.com/ReactiveCocoa/ReactiveCocoa&quot;&gt;ReactiveCocoa&lt;/a&gt; 4 -the FRP framework of choice for said project- was launched with &lt;strong&gt;major&lt;/strong&gt; changes, making it really hard to find good reference material. The ones I found were mostly about making a transition from &lt;code class=&quot;highlighter-rouge&quot;&gt;2.5&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;4.0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here goes some key lessons I learnt the hard way, in the hope that someone in a similar situation as me will find it useful or someone who knows more will correct me if I’m wrong in my understanding of FRP under ReactiveCocoa.&lt;/p&gt;

&lt;h2 id=&quot;frp&quot;&gt;FRP&lt;/h2&gt;
&lt;p&gt;Funcional Reactive Programming is a programming paradigm like many others. The main result of its adoption is more readable code via the sustitution of state by higher level instructions.&lt;/p&gt;

&lt;p&gt;The most common example for state is a register button that will be enabled when both the username and the password are valid, as long as the register button hasn’t been pressed already and we are registering the user via API.&lt;/p&gt;

&lt;p&gt;What imperative programming will normally do is:&lt;br /&gt;
1. Hook into the textfields’ &lt;code class=&quot;highlighter-rouge&quot;&gt;shouldChangeCharactersInRange:replacementString:&lt;/code&gt; delegate method.&lt;br /&gt;
2. Every time the text changes, check whether it’s valid or not.&lt;br /&gt;
3. Check if the counterpart textfield’s text is valid.&lt;br /&gt;
4. Check the &lt;code class=&quot;highlighter-rouge&quot;&gt;isRegistering&lt;/code&gt; property is &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;.&lt;br /&gt;
5. Enable the register button.&lt;br /&gt;
6. Hook into the register button &lt;code class=&quot;highlighter-rouge&quot;&gt;UIControlEventTouchUpInside&lt;/code&gt; event.&lt;br /&gt;
7. When the register button is tapped collect the username and password values, call the register API and set the &lt;code class=&quot;highlighter-rouge&quot;&gt;isRegistering&lt;/code&gt; property to &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now, this is what FRP programming will normally do:&lt;br /&gt;
1. Bind the register button’s enabled property to &lt;em&gt;when both the username and the password are valid, as long as the register button hasn’t been pressed already and we aren’t registering the user via API&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;It sounds like I’m just repeating myself but that’s exactly what FRP lets you do, define each component’s behaviour in a very similar way to which you think about behaviour.&lt;/p&gt;

&lt;p&gt;A different way to think about this is a spreadsheet. All a spreadsheet needs from the user is that each cell has either values or formulas. If a cell’s formula is &lt;code class=&quot;highlighter-rouge&quot;&gt;=A1+(AVG(B1:B10))&lt;/code&gt; you don’t care about how or when you get the result. You can focus on &lt;em&gt;the formula&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This has two main benefits:&lt;br /&gt;
1. You write code in the same way as you think of it, as previously mentioned.&lt;br /&gt;
2. Once the code is written, the behaviour is contained and complete in a few lines of code. Could be more -much more-, but it’ll be all at one place.&lt;/p&gt;

&lt;p&gt;Let’s go over the components in FRP that will enable us to do such a thing.&lt;/p&gt;

&lt;h1 id=&quot;stream&quot;&gt;Stream&lt;/h1&gt;
&lt;p&gt;A &lt;em&gt;cell&lt;/em&gt; in FRP is called a “Stream”.&lt;/p&gt;

&lt;p&gt;You can think of a stream as the history, past, present and future of a property in the sense that they are self contained and inmutable in time; like a river with all it’s water, but you are seeing just one part of it.&lt;/p&gt;

&lt;p&gt;What triggers the river to move? Events.&lt;/p&gt;

&lt;p&gt;Those events are mostly changes, like temperature was 21º and now it’s 25º but could also be something like finishing serving a customer and wanting the next to come to the counter.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NOTE: Streams are often called or represented by Signals, which is a terrible name since they get easily confused with events. You could think of a signal as a semaphore’s light changing&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; from green to red, but in FRP a signal is the semaphore itself.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;bindings&quot;&gt;Bindings&lt;/h1&gt;
&lt;p&gt;What’s the use of a stream if we can’t bind it somewhere?&lt;/p&gt;

&lt;p&gt;What can we bind to a stream? Almost any property, and you know what’s cool? FRP Properties have streams themselves. So you can bind a stream into a property and another property to the first property’s stream.&lt;/p&gt;

&lt;h1 id=&quot;tranformations&quot;&gt;Tranformations&lt;/h1&gt;
&lt;p&gt;A big component of FRP is transformations, they are the &lt;em&gt;formula&lt;/em&gt; in our cell.&lt;/p&gt;

&lt;p&gt;We may have a stream of &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt;s but need to bind them to a &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; property, for instance, enabling a button if a property’s text is larger than 4 chars.&lt;/p&gt;

&lt;p&gt;Transformations transform streams into streams, not into values.&lt;/p&gt;

&lt;h1 id=&quot;chaining&quot;&gt;Chaining&lt;/h1&gt;
&lt;p&gt;This is the &lt;em&gt;Functional&lt;/em&gt; part in Functional Reactive Programming. And it’s available all accorss frameworks that you can chain as many streams, streams transformations and streams combinations (which is a kind of transformation) as you want.&lt;/p&gt;

&lt;p&gt;If you are comfortable with Functional Programming there’s not much more explanation needed.&lt;/p&gt;

&lt;h1 id=&quot;hot-and-cold-signals&quot;&gt;Hot and Cold signals&lt;/h1&gt;
&lt;p&gt;This is a fairly important difference, ignoring it could trigger lots of issues.&lt;/p&gt;

&lt;p&gt;You’ll find many &lt;em&gt;fancy&lt;/em&gt; and more correct definitions than this one, but the key part is what happens when you bind a stream to a property:&lt;br /&gt;
If you get the current value (which was set in the past) alongside with whichever new values are set in the future binded into your property then you are using a &lt;strong&gt;cold signal&lt;/strong&gt;.&lt;br /&gt;
If you only start getting the new values (whichever are set in the future) binded into your property then you are using a &lt;strong&gt;hot signal&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This also applies to &lt;em&gt;events&lt;/em&gt;. A cold signal could be a bank queue that opens up and right away gets a new customer, if any. Whereas a hot signal could be a catastrophe prevention system, you only want to start the siren when the next warning comes in, regardless of whether there was one in the past.&lt;/p&gt;

&lt;h1 id=&quot;next&quot;&gt;Next&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;/2016/03/24/introduction-to-frp-pt2.html&quot;&gt;Part 2&lt;/a&gt;: How to implement this concepts in ReactiveCocoa 4.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;New Oxford American Dictionary: &lt;strong&gt;signal&lt;/strong&gt; |ˈsiɡnəl| (noun) • an event or statement that provides the impulse or occasion for something specified to happen: the champion’s announcement that he was retiring was the signal for scores of journalists to gather at his last match. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 20 Mar 2016 11:33:20 -0300</pubDate>
        <link>http://zerously.com/2016/03/20/introduction-to-frp-pt1.html</link>
        <guid isPermaLink="true">http://zerously.com/2016/03/20/introduction-to-frp-pt1.html</guid>
        
        
      </item>
    
      <item>
        <title>Hello</title>
        <description>&lt;p&gt;I know, I know. I shouldn’t be switching my blog’s url and name so often.&lt;/p&gt;

&lt;p&gt;But Tumblr wasn’t doing such a great job at hosting my posts… and I just decided I’d go lean with &lt;a href=&quot;http://jekyllrb.com&quot;&gt;Jekyll&lt;/a&gt; and &lt;a href=&quot;https://pages.github.com&quot;&gt;Github Pages&lt;/a&gt;, start over, hell, &lt;em&gt;why not&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;You can find my previous writings here:&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com&quot;&gt;mariano.zerously.com&lt;/a&gt; (2013-2015)&lt;br /&gt;
&lt;a href=&quot;http://mythirdblog.wordpress.com&quot;&gt;mythirdblog&lt;/a&gt; (2007-2010)&lt;/p&gt;

&lt;p&gt;I tried importing them, redirecting them, renaming them and honestly, it isn’t wasn’t worth it.&lt;/p&gt;

&lt;p&gt;I’ll save you some time, here are my &lt;strong&gt;favorite posts&lt;/strong&gt; from my past blogs:&lt;br /&gt;
&lt;a href=&quot;https://mythirdblog.wordpress.com/2009/04/25/planning-to-get-rid-of-my-pc/&quot;&gt;Planning to get rid of my PC&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://mythirdblog.wordpress.com/2009/11/18/5-phases-to-become-a-happy-programer/&quot;&gt;5 phases to become a happy programmer&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/18906826372/ios-push-notifications-sends-user-untraceable&quot;&gt;iOS push notifications sends user-untraceable sounds&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/20670689934/keeping-badges-updated&quot;&gt;Keeping badges updated&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/31202489835/just-this&quot;&gt;Just this&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/57244969720/a-proposed-technique-for-offering-users-assistance&quot;&gt;A proposed technique for offering users assistance in the event of a crash&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/57612023714/best-tool-for-making-difficult-decisions&quot;&gt;Best tool for making difficult decisions&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/66670579060/hosting-an-nscoder&quot;&gt;Hosting an NSCoder&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/67763971947/best-desktop-ive-ever-had&quot;&gt;Best desktop I’ve ever had&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://mariano.zerously.com/post/88906173465/best-desktop-ive-ever-had-yet&quot;&gt;Best desktop I’ve ever had, yet&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Have fun.&lt;/p&gt;
</description>
        <pubDate>Sat, 19 Mar 2016 18:59:52 -0300</pubDate>
        <link>http://zerously.com/2016/03/19/hello.html</link>
        <guid isPermaLink="true">http://zerously.com/2016/03/19/hello.html</guid>
        
        
      </item>
    
  </channel>
</rss>
